---
title: 面向对象
date: 2023-04-25 15:54:09
permalink: /golang/base/oop/
categories:
  - golang
  - 基础
tags:
  - golang
---

# 面向对象相关

## struct

```go
package main

import "fmt"

// UserModel 如果struct名是大写,则表示此结构体在别的包能够被访问 /**
type UserModel struct {
	//如果属性名是大写,则表示该属性在别的包也能够被访问
	Username string
	Password string
	//小写则只能包内访问
	age int
}

// Show 不传入*UserModel,那么变量是数据副本而不是引用
// 默认传入调用当前方法的对象实例 即下面的 user变量
func (user UserModel) Show() {
	fmt.Println("Username = ", user.Username)
	fmt.Println("Password = ", user.Password)
	fmt.Println("age = ", user.age)
}

// 方法也是一样的 方法名的大小写代表了此方法是否能被包外访问
// 这里传入*UserModel表示是引用传递
// 默认传入调用当前方法的对象实例 即下面的 user变量
func (user *UserModel) updateUser() {
	user.age = 1111
}

func main() {

	user := UserModel{Username: "zdk", Password: "123", age: 22}
	user.Show()
	fmt.Println("user:", user)
	fmt.Println("-------------")

	user.updateUser()
	fmt.Println("update-user:", user)

}
```

> 即，struct名、属性名、方法名等，大写表示public包外可访问，小写表示private包外不可访问

## 方法

> 方法总是绑定对象实例,并隐式的将实例作为第一实参(receiver),方法的语法如下

```go
func(receiver ReceiverType) funcName(parameters) (results)
```

- 参数receiver可重新命名.如方法中未曾使用,可省略参数名
- **参数receiver类型可以是T或\*T.基类型T不能是接口或指针**
- 不支持重载方法,也就是说,不能定义名字相同但是不同参数的方法

举例：为上面的UserModel对象定义的方法：

```go
func (user *UserModel) updateUser() {
	user.age = 1111
}
```

> 这里没有传入参数，user变量就是调用者本身







### 重写

> 子类可以重写父类的方法，如上述代码中的
>
> ```go
> func (superMan SuperMan) Walk() {
> 	fmt.Println("superMan--Eat()")
> }
> ```
>
> 在superMan对象进行调用时，就不再是调用`func (human Human) Walk()`方法了，而是调用重写后的方法



## 继承

> 在golang中，如果一个struct嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现继承特性。

例如：

```go
package main

import "fmt"

type Human struct {
	name string
	sex  string
}

type SuperMan struct {
	// SuperMan类继承了Human类的方法和属性
	Human
	level int
}

func (human Human) Eat() {
	fmt.Println("Human--Eat()")
}

func (human Human) Walk() {
	fmt.Println("Human--Eat()")
}

func (superMan SuperMan) Walk() {
	fmt.Println("superMan--Eat()")
}

func main() {

	human := Human{"test", "女"}
	human.Walk()

	fmt.Println("-----------------")

	superMan := SuperMan{Human{"zdk", "男"}, 1}
	superMan.name = "张迪凯"
	superMan.Eat()
	superMan.Walk()
}
```

> 以上代码中，实现了SuperMan类继承了Human类，superMan对象可以直接.属性名来访问Human类的属性。

注意：

1. 结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或者小写的字段、方法，都可以使用
2. 匿名结构体字段访问可以简化，即不需要`superMan.Human.name`，而是直接`superMan.name`
   - 这里是先看superMan有没有name属性，如果有就直接调用
   - 如果没有就回去看SuperMan中嵌入的结构体中的有没有name属性，如果有则调用，没有就继续找别的结构体，如果找完所有内嵌结构体都找不到，就报错
3. 当结构体和匿名结构体有相同的字段或者方法时，编译器选择采用就近访问原则访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分
4. 结构体嵌入两个(或多个)匿名结构体，如两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的子弹和方法)，在访问时，就必须指定匿名结构体名字，否则编译报错
5. 如果一个struct嵌套了一个有名结构体这种模式就是组合，如果是组合关系，那么在访问结构体的字段或方法时，就必须带上结构体的名字

### 多重继承

- 如果一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现多重继承
- 如嵌入的匿名结构体有相同的字段名或者方法名，则在访问时，需要通过匿名结构体类型名来区分
- 为了保证代码的简洁性，尽量不使用多重继承



## 多态的实现与基本要素

### interface

定义格式如下：

```go
type 接口名 interface{
方法名1( 参数列表1 ) 返回值列表1
方法名2( 参数列表2 ) 返回值列表2
…
}
```

说明：

1. 接口名：用type将接口自定义的一个类型名。Go语言的接口名单词后面通常会加 er，比如写操作的接口叫 Writer 等。接口名要尽量突出接口类型的含义
2. 方法名：当方法名的首字母以及该接口名首字母都是大写时，那么这个方法可以被接口所在的包（package）之外的代码访问
3. 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可省略
