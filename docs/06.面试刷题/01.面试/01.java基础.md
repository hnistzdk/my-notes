---
title: java基础
date: 2022-02-20 19:57:49
permalink: /work/interview/java
categories:
  - 面试刷题
  - 面试
tags:
  - 
---

## 集合框架

### List

#### ArrayList扩容

> 新容量为原数组长度的1.5倍，如果扩容后的容量依然小于需要的容量，就将需要容量作为数组的长度。
>
> 然后将原数组元素拷贝到新的数组并返回

```java
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

#### ArrayList在jdk7、8的不同

1. jdk7

   - ArrayList list = new ArrayList()；//底层elementData数组初始大小为10
   - 执行add()时，如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中

2. jdk8

   > 底层elementData初始化为{}，并没有初始化为长度10的数组，而是第一次调用add的时候，底层才创建了长度为10的数组，并将数据加入到数组。后续的添加和扩容操作与JDK7无异

3. 总结：

   > JDK7中的ArrayList的对象创建类似于单例模式中的饿汉式，而JDK8中的类似于懒汉式，延迟了数组的创建，节省了内存





### Set

#### HashSet

> 底层也是数组(是一个HashMap)，初始容量为16，当如果使用率超过0.75，(16*0.75=12)就会扩大容量为原来的2倍。(16扩容为32，依次为64,128.....等) 详情见HashMap源码

添加元素的过程

> 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为:索引位置），判断数组此位置上是否已经有元素: 
>
> ​	如果此位置上没有其他元素，则元素α添加成功。---->情况1 
>
> ​	如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值: 如果hash值不相同，则元素α添加成功。---->情况2 
>
> ​	如果hash值相同，进而需要调用元素α所在类的equals()方法: 如果equals()返回true,元素α添加失败 如果equals()返回false,则元素α添加成功。---->情况3
>
> 
>
> 对于添加成功的情况2和情况3而言:元素a与已经存在指定索引位置上数据以链表的方式存储。
>
> 
>
> jdk7：元素α放到数组中，指向原来的元素。 jdk8：原来的元素在数组中，指向元素α
