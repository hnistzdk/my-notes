---
title: Hystrix
date: 2022-10-28 17:01:32
permalink: /SpringCloud/Hystrix/
categories:
  - 框架
  - SpringCloud
tags:
  - Hystrix
---
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Hystrix](#hystrix)
  - [概述](#%E6%A6%82%E8%BF%B0)
    - [分布式系统面临的问题](#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98)
      - [服务雪崩](#%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9)
    - [是什么](#%E6%98%AF%E4%BB%80%E4%B9%88)
    - [能干嘛](#%E8%83%BD%E5%B9%B2%E5%98%9B)
    - [官方资料](#%E5%AE%98%E6%96%B9%E8%B5%84%E6%96%99)
  - [Hystrix重要概念](#hystrix%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5)
    - [服务降级(fallback)](#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7fallback)
      - [哪些情况会触发降级](#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E8%A7%A6%E5%8F%91%E9%99%8D%E7%BA%A7)
    - [服务熔断(break)](#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%ADbreak)
    - [服务限流(flowlimit)](#%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81flowlimit)
  - [Hystrix案例](#hystrix%E6%A1%88%E4%BE%8B)
    - [payment](#payment)
      - [pom](#pom)
      - [yaml](#yaml)
      - [service](#service)
      - [controller](#controller)
      - [测试](#%E6%B5%8B%E8%AF%95)
      - [压测](#%E5%8E%8B%E6%B5%8B)
    - [order](#order)
      - [新建feign-hystrixOrder80](#%E6%96%B0%E5%BB%BAfeign-hystrixorder80)
    - [解决](#%E8%A7%A3%E5%86%B3)
    - [Hystrix降级配置](#hystrix%E9%99%8D%E7%BA%A7%E9%85%8D%E7%BD%AE)
      - [提供侧](#%E6%8F%90%E4%BE%9B%E4%BE%A7)
      - [消费侧(一般都在此侧做降级配置)](#%E6%B6%88%E8%B4%B9%E4%BE%A7%E4%B8%80%E8%88%AC%E9%83%BD%E5%9C%A8%E6%AD%A4%E4%BE%A7%E5%81%9A%E9%99%8D%E7%BA%A7%E9%85%8D%E7%BD%AE)
      - [全局服务降级DefaultProperties](#%E5%85%A8%E5%B1%80%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7defaultproperties)
      - [FeignFallback配置](#feignfallback%E9%85%8D%E7%BD%AE)
  - [Hystrix工作流程](#hystrix%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B)
  - [服务监控 Hystrix Dashboard](#%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7-hystrix-dashboard)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

---

# Hystrix

## 概述

### 分布式系统面临的问题

> **复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败**。

#### 服务雪崩

> 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的**“扇出”**。**如果扇出的链路上某个微服务的调用响应时间过长或者不可用**，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。
>
> <br/>
>
> 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列、线程和其他系统资源紧张，进而导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。

### 是什么

> Hystrix是一个用于处理分布式系统的**延迟**和**容错**的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，**不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性**。
>
> <br/>
>
> "断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控〔类似熔断保险丝)，**向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常**，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

### 能干嘛

- 服务降级

- 服务熔断

- 接近实时的监控

### 官方资料

wiki:

**https://github.com/Netflix/Hystrix/wiki/How-To-Use**

Hystrix已停止更新，进入仅维护状态



## Hystrix重要概念

### 服务降级(fallback)

- 服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback

#### 哪些情况会触发降级

- 程序运行异常
- 超时
- 服务熔断触发服务降级
- 线程池/信号量打满

### 服务熔断(break)

> 类比保险丝，在达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。
>
> 服务降级->进而熔断->一段时间再恢复正常调用

### 服务限流(flowlimit)

> 限制访问量(秒杀等高并发操作)

## Hystrix案例

新建cloud-provider-hystrix-payment8001工程

### payment

#### pom

新增hystrix的依赖即可

> 这里由于cloud2020已经没有hystrix的版本了，所以需要自己加一个引入

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
    <version>2.2.10.RELEASE</version>
</dependency>
```

#### yaml

```yaml
server:
  port: 8001

# 服务名称  （必写）
spring:
  application:
    name: cloud-payment-hystrix-service

eureka:
  client:
    # false表示不想注册中心注册自己
    register-with-eureka: true
    # false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要检查服务
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/
```

#### service

```java
package com.zdk.springcloud.service;

import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

/**
 * @Description
 * @Author zdk
 * @Date 2022/10/28 18:03
 */
@Service
public class HystrixPaymentService {

    public String paymentInfoOk(Integer id){
        return "线程池："+Thread.currentThread().getName()+" paymentInfoOk,id:  "+id+"\t"+"欧克欧克";
    }

    public String paymentInfoTimeout(Integer id){
        int time = 3;
        try {
            TimeUnit.SECONDS.sleep(time);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return "线程池："+Thread.currentThread().getName()+" paymentInfoTimeout,id:  "+id+"\t"+"欧克欧克 耗时："+time+"秒";
    }
}
```

#### controller

```java
package com.zdk.springcloud.controller;

import com.zdk.springcloud.service.HystrixPaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Description
 * @Author zdk
 * @Date 2022/10/28 18:07
 */
@Slf4j
@RestController
public class HystrixPaymentController {

    @Autowired
    private HystrixPaymentService hystrixPaymentService;

    @Value("${server.port}")
    private String serverPort;

    @GetMapping("/payment/hystrix/ok/{id}")
    public String paymentInfoOk(@PathVariable Integer id){
        String result = hystrixPaymentService.paymentInfoOk(id);
        log.info("*****result："+result);
        return result;
    }

    @GetMapping("/payment/hystrix/timeout/{id}")
    public String paymentInfoTimeout(@PathVariable Integer id){
        String result = hystrixPaymentService.paymentInfoTimeout(id);
        log.info("*****result："+result);
        return result;
    }
}

```

#### 测试

启动eureka7001，再启动此8001payment，访问测试

![image-20221028181523002](https://images.zaiolos.top/images/202210281815070.png)

目前访问正常

#### 压测

> 使用jemter 2万qps请求timeout，此时再去请求ok接口，会发现ok接口响应速度明显变慢了

### order

#### 新建feign-hystrixOrder80

> 压测是一样的结果，会出现卡顿

### 解决

有三种情况需要进行服务降级处理：

- 对方服务(8001)超时了，调用者(80)不能一直卡死等待，`调用者`必须有服务降级
- 对方服务(8001)宕机了，调用者(80)不能一直等待，`调用者`必须有服务降级
- 对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，`调用者`必须自己处理服务降级



### Hystrix降级配置

#### 提供侧

1. 首先在主启动类上增加`@EnableCircuitBreaker`注解

2. 编写方法

   ```java
   package com.zdk.springcloud.service;
   
   import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
   import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
   import org.springframework.stereotype.Service;
   
   import java.util.concurrent.TimeUnit;
   
   /**
    * @Description
    * @Author zdk
    * @Date 2022/10/28 18:03
    */
   @Service
   public class HystrixPaymentService {
   
       public String paymentInfoOk(Integer id){
           return "线程池："+Thread.currentThread().getName()+" paymentInfoOk,id:  "+id+"\t"+"欧克欧克";
       }
   
       @HystrixCommand(fallbackMethod = "paymentInfoTimeoutHandler", commandProperties =
               {@HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")})
       public String paymentInfoTimeout(Integer id){
           int a = 10/0;
           int time = 5;
           try {
               TimeUnit.SECONDS.sleep(time);
           } catch (InterruptedException e) {
               throw new RuntimeException(e);
           }
           return "线程池："+Thread.currentThread().getName()+" paymentInfoTimeout,id:  "+id+"\t"+"欧克欧克 耗时："+time+"秒";
       }
   
       public String paymentInfoTimeoutHandler(Integer id){
           return "线程池："+Thread.currentThread().getName()+"id:"+id+"  超时或运行报错->服务降级咯~~~~~";
       }
   
   }
   ```

   > 重要的是`@HystrixCommand`注解，此注解声明的方法即为被Hystrix接管的方法，`fallbackMethod`参数用来指定调用因异常或超时失败后，兜底处理的降级的方法的名称，是**全限定名(同一类中可以省略)**
   >
   > <br/>
   >
   > 它的commandProperties属性，是`@HystrixProperty`注解的数组形式，name指定要配置的属性名称，value配置值，比如`execution.isolation.thread.timeoutInMilliseconds`就是指定服务调用的最大超时时间，value单位为毫秒，超过这个时间，Hystrix会调用`fallbackMethod`指定的方法作为返回

3. 测试

   ![image-20221031152329801](https://images.zaiolos.top/images/202210311523874.png)

#### 消费侧(一般都在此侧做降级配置)

> 消费侧使用feign进行服务调用

1. 主启动类增加`@EnableHystrix`注解，开启Hystrix

   ```java
   //......
   @EnableCircuitBreaker
   public @interface EnableHystrix {
       //可以看到这个注解实际就是EnableCircuitBreaker注解，只是特定用于Hystrix
   }
   ```

2. 为了方便，就在消费侧controller中编写测试

   ```java
   @GetMapping(value = "/consumer/payment/hystrix/timeout1/{id}")
   @HystrixCommand(fallbackMethod = "timeoutHandler", commandProperties =
           {@HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "1500")})
   public String timeout1(@PathVariable("id") Integer id) {
       return paymentFeignService.paymentInfoTimeout(id);
   }
   public String timeoutHandler(@PathVariable("id") Integer id){
       return "消费者80发现被调用方系统繁忙~~~~";
   }
   ```

3. 结果：

   - 在提供侧也配置了超时的时候，如果消费侧所需的时间要更短(1500<2000)，那么会在消费侧直接降级，不会调用到提供侧的降级方法，相反，如果时间符合消费侧要求，就走提供侧降级

     ```java
     @HystrixCommand(fallbackMethod = "paymentInfoTimeoutHandler", commandProperties =
             {@HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "2000")})
     public String paymentInfoTimeout(Integer id){
           int a = 10/0;
         int time = 5;
         try {
             TimeUnit.SECONDS.sleep(time);
         } catch (InterruptedException e) {
             throw new RuntimeException(e);
         }
         return "线程池："+Thread.currentThread().getName()+" paymentInfoTimeout,id:  "+id+"\t"+"欧克欧克 耗时："+time+"秒";
     }
     public String paymentInfoTimeoutHandler(Integer id){
         return "线程池："+Thread.currentThread().getName()+"id:"+id+"  超时或运行报错->服务降级咯~~~~~";
     }
     ```

   - 同时，如果消费侧先出现异常，那么也是在消费侧直接降级，不进入提供侧降级

#### 全局服务降级DefaultProperties

> 因为如果每个业务方法都对应一个fallback方法的话，会导致代码大量重复、膨胀

我们使用`@DefaultProperties(defaultFallback="")`来配置全局的服务降级方法

1. 在消费侧的controller上增加`@DefaultProperties(defaultFallback = "paymentGlobalFallbackMethod")`

2. 编写paymentGlobalFallbackMethod方法

   ```java
   //下面是全局fallback方法
   public String paymentGlobalFallbackMethod(){
       return "Global异常处理信息,请稍后再试~~~~~";
   }
   ```

3. 去掉原来指明的fallback方法注解，增加`@HystrixCommand`注解，表示不指定fallback，用全局的

   ```java
       @GetMapping(value = "/consumer/payment/hystrix/timeout1/{id}")
   //    @HystrixCommand(fallbackMethod = "timeoutHandler", commandProperties =
   //            {@HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "1500")})
       @HystrixCommand
       public String timeout1(@PathVariable("id") Integer id) {
           //模拟报错
   		int a = 10/0;
           return paymentFeignService.paymentInfoTimeout(id);
       }
   ```

测试会发现，此时就走了全局的方法

![image-20221031161144950](https://images.zaiolos.top/images/202210311611001.png)

#### FeignFallback配置

> 上面的全局配置，是在controller层接口上的配置，导致代码耦合严重，我们可以在Feign的Service里面，对所有的外部服务的接口，进行统一的降级配置，这样就不需要在controller层写了

1. 新建一个类，让其实现feign的service接口

   ```java
   @Component
   public class PaymentFallbackService implements PaymentFeignHystrixService{
       @Override
       public String paymentInfoOk(Integer id) {
           return "调用失败-----PaymentFallbackService fallback-paymentInfoOk";
       }
   
       @Override
       public String paymentInfoTimeout(Integer id) {
           return "调用失败-----PaymentFallbackService fallback-paymentInfoTimeout";
       }
   }
   ```

2. 开启yaml配置

   ```yaml
   feign:
     circuitbreaker:
       enabled: true
   ```

3. 将提供者服务关闭，进行测试，发现走到我们实现的新方法

   ![image-20221031163226122](https://images.zaiolos.top/images/202210311632169.png)





## Hystrix工作流程



## 服务监控 Hystrix Dashboard
