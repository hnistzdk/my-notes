---
title: 秒杀项目过程笔记
date: 2022-05-15 20:24:04
permalink: /project/seckill
categories:
  - 项目
  - 秒杀项目
tags:
  - 
---



## Java秒杀方案



### 1、页面优化

#### 1.1、缓存

#### 1.2、静态化分离



### 2、服务优化

#### 2.1、RabbitMQ消息队列

#### 2.2、接口优化

#### 2.3、分布式锁



### 3、安全优化

#### 3.1、隐藏秒杀地址

#### 3.2、验证码

#### 3.3、接口限流



### 4、分布式会话

#### 4.1、用户登录

##### 登录逻辑

> 系统是使用mobile作为id的，密码是经过了`MD5(MD5(pass明文+固定salt)+salt)`两次md5加密的；
>
> 第一次是前端通过固定salt先对密码加密一次
>
> ```js
> //salt
> var g_passsword_salt="1a2b3c4d"
> 
> let inputPass = $("#password").val();
> let salt = g_passsword_salt;
> let str = salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4);
> let password = md5(str);
> ```
>
> 第二次是后端再通过这个用户注册时生成的salt再对密码加密一次(注册没有写 逻辑是这样的)
>
> 
>
> 所以登录的时候，先通过手机号判断是否有这个用户，有的话再看他的密码与使用他的salt加密后的 输入密码  是否相等，不等则抛出对应GlobalException。
>
> 
>
> 验证成功以后，为这个用户生成一个形式为UUID的凭证ticket，并把它存入redis并设置过期时间，然后封装为一个cookie返回给前端

```java
```







##### 参数校验

> 为了避免写太多的StringUtils.xxx这种冗余代码，我们可以引入validation的包来处理。下面引入依赖
>
> ```xml
> <!--        validation组件-->
>         <dependency>
>             <groupId>org.springframework.boot</groupId>
>             <artifactId>spring-boot-starter-validation</artifactId>
>         </dependency>
> ```





**方式1:使用组件自带的校验**

1. 首先，如果要校验的参数是对象，则将`@Valid`加对象前面(如果是String、Integer这些，直接使用对应的`@NotNull`等注解即可)。

   ```java
   	//这里注意，必须要在Controller的方法之中使用
   	//测试如果在service的方法中使用，不会生效
   	@PostMapping("/doLogin")
       @ResponseBody
       public ApiResp toLogin(@Valid LoginVo loginVo) {
           log.info("loginVo:{}",loginVo);
           return userService.doLogin(loginVo);
       }
   ```

2. 在类的属性上加上对应的注解即可，还可以在注解中指定校验失败时的message

   ```java
   @Data
   public class LoginVo {
       @NotBlank(message = "手机号不能为空")
       private String mobile;
   
       @NotBlank(message = "密码不能为空")
       @Length(min = 32)
       /**
        * 可以用Pattern正则对手机号进行验证，如果用了，在不满足时，会抛出BindException
        * 此时需要我们手动处理(使用@RestControllerAdvice)，否则前端就得不到具体的响应
        *
        * 当然 也可以自定义注解
        */
       @Pattern(regexp = "[1]([3-9])[0-9]{9}$")
       private String password;
   }
   ```



**方式2:通过自定义注解实现自定义的校验**

1. 参考`@NotNull`注解定义我们的手机号格式校验注解

   ```java
   @Target({METHOD,FIELD,ANNOTATION_TYPE,CONSTRUCTOR,PARAMETER,TYPE_USE})
   @Retention(RUNTIME)
   @Documented
   //这里是指定由哪个类来具体进行校验
   //这个类需实现ConstraintValidator<A extends Annotation,T>接口并实现所有方法
   @Constraint(validatedBy = {IsMobileValidator.class})
   public @interface IsMobile {
       //标识这个属性是必填的
       boolean required() default true;
   	//默认错误信息
       String message() default "手机号码格式错误";
   
       Class<?>[] groups() default {};
   
       Class<? extends Payload>[] payload() default {};
   }
   ```

2. 定义`ConstraintValidator<A extends Annotation,T>接口`实现类，实现它的两个方法

   ```java
   public class IsMobileValidator implements ConstraintValidator<IsMobile,String> {
       private boolean required = false;
   
       //具体的校验逻辑
       @Override
       public boolean isValid(String value, ConstraintValidatorContext context) {
           //如果不是必填的 并且为空 直接返回true
           if (!required && StringUtils.isBlank(value)){
               return true;
           }
           //如果必填 或者非必填时它填了  就需要校验
           return ValidatorUtil.isMobile(value);
       }
   
       //在这个方法实现对required的初始化
       @Override
       public void initialize(IsMobile constraintAnnotation) {
           required = constraintAnnotation.required();
       }
   }
   ```

   校验工具类：

   ```java
   public class ValidatorUtil {
       private static final Pattern MOBILE_PATTEN = Pattern.compile("[1]([3-9])[0-9]{9}$");
   
       /**
        * 手机号码校验
        * @param mobile
        * @return
        */
       public static boolean isMobile(String mobile) {
           if (StringUtils.isEmpty(mobile)) {
               return false;
           }
           Matcher matcher = MOBILE_PATTEN.matcher(mobile);
           return matcher.matches();
       }
   }
   ```

3. 在字段上加上自定义注解即可

   ```java
   @Data
   public class LoginVo {
       @NotBlank(message = "手机号不能为空")
       @IsMobile
       private String mobile;
   
       @NotBlank(message = "密码不能为空")
       @Length(min = 32)
       private String password;
   }
   ```



> 这样我们就完成了参数的校验，但是我们会发现，此时虽然参数校验成功了，后端代码并没有往下执行了，但前端并任何提示，这其实是因为，参数校验不通过时，Validator抛出了`BindException`(大都是抛出它的子类`MethodArgumentNotValidException`)，而我们并没有对这个异常进行处理，所以前端没有获取到对应的响应信息，所以我们需要添加一个全局异常的处理类来进行处理



##### 参数校验的全局异常处理

1. 自定义全局异常类。一定要继承RuntimeException类，而不是Exception类，如果是Exception类的话，抛出异常是需要在方法上throws的

   ```java
   /**
    * @author zdk
    * @date 2022/5/15 18:13
    * 全局异常类
    */
   @Data
   @AllArgsConstructor
   @NoArgsConstructor
   public class GlobalException extends RuntimeException{
       private ApiRespEnum apiRespEnum;
   }
   ```

2. 这里选择使用`@RestControllerAdvice`类型的全局异常处理类

   ```java
   @Slf4j
   @RestControllerAdvice
   public class GlobalExceptionHandler {
       
       @ExceptionHandler(Exception.class)
       public ApiResp handle(Exception e){
           //处理自定义的异常
           if (e instanceof GlobalException){
               GlobalException exception = (GlobalException) e;
               return ApiResp.error(exception.getApiRespEnum());
           }
           //处理使用的Validator组件的异常
           else if(e instanceof BindException) {
               BindException bindException = (BindException) e;
               ApiResp respBean = ApiResp.error(ApiRespEnum.BIND_ERROR);
               respBean.setMessage("参数校验异常：" + bindException.getBindingResult().getAllErrors().get(0).getDefaultMessage());
               return respBean;
           }
           e.printStackTrace();
           log.error("异常信息:{}",e.getMessage());
           return ApiResp.error(ApiRespEnum.ERROR);
       }
   
   }
   ```



::: tip 总结



:::







#### 4.2、共享Session



### 5、功能开发

#### 5.1、商品列表

#### 5.2、商品详情

#### 5.3、秒杀

#### 5.4、订单详情



### 6、系统压测

#### 6.1、JMeter入门

#### 6.2、自定义变量

#### 6.3、正式压测
