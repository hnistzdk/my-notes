---
title: 回溯
date: 2022-03-18 10:58:32
permalink: /work/algorithm/backtrack
categories:
  - 面试刷题
  - 刷题
tags:
  - 回溯
---

## 概要及框架

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。



框架

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。



> 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：
>
> **写 `backtrack` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。
>
> 其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？
>
> 某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。



### 1.(`medium`)全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]



思路：

> 回溯：
>
> 我们使用一个boolean数组flag来保存当前的所有选择的状态，为true证明已被选则，不可被选。
>
> 使用LinkedList来记录每次结果，当它的size到达nums的length的时候，证明产生一个排列，将其加入到res中
>
> `注：res.add(new LinkedList<>(path));`老问题了
>
> 1. 在回溯方法中，如果当前的path长度等于nums长度，证明产生一个排列
> 2. 然后对所有的可选选择进行选择，将其加入到path中,将选择标志flag[i]记为true
> 3. 然后执行递归
> 4. 递归完成后，将path中的最后一个移出，然后将选择标志flag[i]记为false
>
> 2、4步即体现了`在递归调用之前「做选择」，在递归调用之后「撤销选择」`





代码：

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] flag = new boolean[nums.length];
        backtrack(new LinkedList<>(),nums,flag);
        return res;
    }

    public void backtrack(LinkedList<Integer> path,int[] nums,boolean[] flag){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        //遍历所有选择
        for(int i=0;i<nums.length;i++){
            //已选择的 不再选择
            if(flag[i]){
                continue;
            }
            //选择
            path.add(nums[i]);
            //标记置为已选择
            flag[i] = true;
            //递归
            backtrack(path,nums,flag);
            //撤销选择
            path.removeLast();
            //标记置为未选择
            flag[i] = false;
        }
    }
}
```



### 2.(`medium`)全排列2

题目与上题类似，只是数组现在包含重复数字，且要求返回的是所有不重复的全排列



思路：

> 大题思路与上题一致，需要解决的问题：
>
> 如何筛选重复的排列，即减枝
>
> 
>
> 要解决重复问题，我们只要设定一个规则，保证在填第i个数的时候重复数字只会被填入一次即可。而在本题解中，我们选择`对原数组排序`，`保证相同的数字都相邻`，然后`每次填入的数一定是这个数所在重复数集合中「从左往右第一个未被填过的数字」`，即如下的判断条件：
>
> ```java
> if (i > 0 && nums[i] == nums[i - 1] && !flag[i - 1]) {
>     continue;
> }
> ```
>
> 这个判断条件保证了对于重复数的集合，一定是从左往右逐个填入的。
>
> 假设我们有 33 个重复数排完序后相邻，那么我们一定保证每次都是拿从左往右第一个未被填过的数字，即整个数组的状态其实是保证了 [未填入，未填入，未填入] 到 [填入，未填入，未填入]，再到 [填入，填入，未填入]，最后到 [填入，填入，填入] 的过程的，因此可以达到去重的目标。



代码：

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        boolean[] flag = new boolean[nums.length];
        backtrack(new LinkedList<>(),nums,flag);
        return res;
    }

    public void backtrack(LinkedList<Integer> path,int[] nums,boolean[] flag){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        //遍历所有选择
        for(int i=0;i<nums.length;i++){
            //已选择的 不再选择
            if(flag[i]){
                continue;
            }
            //如果前面的相邻相等元素没有用过，则跳过
            if(i>0&&nums[i]==nums[i-1]&&!flag[i-1]){
                continue;
            }
            //选择
            path.add(nums[i]);
            //标记置为已选择
            flag[i] = true;
            //递归
            backtrack(path,nums,flag);
            //撤销选择
            path.removeLast();
            //标记置为未选择
            flag[i] = false;
        }
    }
}
```

