<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络 | DK&#39;s Notes</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/my-notes/img/logo.jpg">
    <link rel="stylesheet" href="/my-notes//at.alicdn.com/t/font_3334662_k54hl9700p.css">
    <link rel="stylesheet" href="/my-notes//at.alicdn.com/t/font_3334662_k54hl9700p.css">
    <link rel="stylesheet" href="/my-notes//at.alicdn.com/t/font_3114978_qe0b39no76.css">
    <link rel="stylesheet" href="/my-notes//at.alicdn.com/t/font_3334691_b03dsaqrwck.css">
    <meta name="description" content="时不我待，舍我其谁">
    <meta name="keywords" content="Java">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/my-notes/assets/css/0.styles.565c6041.css" as="style"><link rel="preload" href="/my-notes/assets/js/app.7f931ee0.js" as="script"><link rel="preload" href="/my-notes/assets/js/2.e52a17f8.js" as="script"><link rel="preload" href="/my-notes/assets/js/168.23aca72c.js" as="script"><link rel="preload" href="/my-notes/assets/js/6.bcc16901.js" as="script"><link rel="prefetch" href="/my-notes/assets/js/10.fee8f7ec.js"><link rel="prefetch" href="/my-notes/assets/js/100.9be19fac.js"><link rel="prefetch" href="/my-notes/assets/js/101.9aaae740.js"><link rel="prefetch" href="/my-notes/assets/js/102.a72c0165.js"><link rel="prefetch" href="/my-notes/assets/js/103.d47527c3.js"><link rel="prefetch" href="/my-notes/assets/js/104.d5bae560.js"><link rel="prefetch" href="/my-notes/assets/js/105.fdb07f67.js"><link rel="prefetch" href="/my-notes/assets/js/106.b89b7d37.js"><link rel="prefetch" href="/my-notes/assets/js/107.a9d142eb.js"><link rel="prefetch" href="/my-notes/assets/js/108.1b8c8817.js"><link rel="prefetch" href="/my-notes/assets/js/109.0cd465a0.js"><link rel="prefetch" href="/my-notes/assets/js/11.75b40e53.js"><link rel="prefetch" href="/my-notes/assets/js/110.4c56723c.js"><link rel="prefetch" href="/my-notes/assets/js/111.12b9cb85.js"><link rel="prefetch" href="/my-notes/assets/js/112.3f791546.js"><link rel="prefetch" href="/my-notes/assets/js/113.d9998b70.js"><link rel="prefetch" href="/my-notes/assets/js/114.faf0da70.js"><link rel="prefetch" href="/my-notes/assets/js/115.35d9b5f6.js"><link rel="prefetch" href="/my-notes/assets/js/116.13fbe1ab.js"><link rel="prefetch" href="/my-notes/assets/js/117.bffe4459.js"><link rel="prefetch" href="/my-notes/assets/js/118.eabefad3.js"><link rel="prefetch" href="/my-notes/assets/js/119.8593c8a5.js"><link rel="prefetch" href="/my-notes/assets/js/12.34db197a.js"><link rel="prefetch" href="/my-notes/assets/js/120.f5b73620.js"><link rel="prefetch" href="/my-notes/assets/js/121.d3137f51.js"><link rel="prefetch" href="/my-notes/assets/js/122.f47bca90.js"><link rel="prefetch" href="/my-notes/assets/js/123.6d846b88.js"><link rel="prefetch" href="/my-notes/assets/js/124.49825ebc.js"><link rel="prefetch" href="/my-notes/assets/js/125.6d3a9ce5.js"><link rel="prefetch" href="/my-notes/assets/js/126.eeef761b.js"><link rel="prefetch" href="/my-notes/assets/js/127.0f7e28c1.js"><link rel="prefetch" href="/my-notes/assets/js/128.4a35f42a.js"><link rel="prefetch" href="/my-notes/assets/js/129.e364bc33.js"><link rel="prefetch" href="/my-notes/assets/js/13.ab02aa59.js"><link rel="prefetch" href="/my-notes/assets/js/130.1299fc06.js"><link rel="prefetch" href="/my-notes/assets/js/131.61faa498.js"><link rel="prefetch" href="/my-notes/assets/js/132.9e46a3c4.js"><link rel="prefetch" href="/my-notes/assets/js/133.0b6e6f7f.js"><link rel="prefetch" href="/my-notes/assets/js/134.6724b7a7.js"><link rel="prefetch" href="/my-notes/assets/js/135.1d3daca0.js"><link rel="prefetch" href="/my-notes/assets/js/136.190f2a28.js"><link rel="prefetch" href="/my-notes/assets/js/137.5ce96397.js"><link rel="prefetch" href="/my-notes/assets/js/138.c0b55b02.js"><link rel="prefetch" href="/my-notes/assets/js/139.068ed7d7.js"><link rel="prefetch" href="/my-notes/assets/js/14.721e1994.js"><link rel="prefetch" href="/my-notes/assets/js/140.5226be4f.js"><link rel="prefetch" href="/my-notes/assets/js/141.196d1aa6.js"><link rel="prefetch" href="/my-notes/assets/js/142.11cbb52f.js"><link rel="prefetch" href="/my-notes/assets/js/143.509f8300.js"><link rel="prefetch" href="/my-notes/assets/js/144.436415bf.js"><link rel="prefetch" href="/my-notes/assets/js/145.a25cd8bc.js"><link rel="prefetch" href="/my-notes/assets/js/146.a2d1d780.js"><link rel="prefetch" href="/my-notes/assets/js/147.1cac4e0a.js"><link rel="prefetch" href="/my-notes/assets/js/148.5c361eba.js"><link rel="prefetch" href="/my-notes/assets/js/149.f62eacfa.js"><link rel="prefetch" href="/my-notes/assets/js/15.35ef567c.js"><link rel="prefetch" href="/my-notes/assets/js/150.80b0aa20.js"><link rel="prefetch" href="/my-notes/assets/js/151.6f0e31d8.js"><link rel="prefetch" href="/my-notes/assets/js/152.86efa86d.js"><link rel="prefetch" href="/my-notes/assets/js/153.d6605e26.js"><link rel="prefetch" href="/my-notes/assets/js/154.e5b33cc7.js"><link rel="prefetch" href="/my-notes/assets/js/155.5d3cf278.js"><link rel="prefetch" href="/my-notes/assets/js/156.bcb9784f.js"><link rel="prefetch" href="/my-notes/assets/js/157.ca3b8e8c.js"><link rel="prefetch" href="/my-notes/assets/js/158.eb0116b8.js"><link rel="prefetch" href="/my-notes/assets/js/159.309a26da.js"><link rel="prefetch" href="/my-notes/assets/js/16.ca698d39.js"><link rel="prefetch" href="/my-notes/assets/js/160.ce6e9321.js"><link rel="prefetch" href="/my-notes/assets/js/161.ac24f13a.js"><link rel="prefetch" href="/my-notes/assets/js/162.c3390211.js"><link rel="prefetch" href="/my-notes/assets/js/163.8267154f.js"><link rel="prefetch" href="/my-notes/assets/js/164.3ce822f9.js"><link rel="prefetch" href="/my-notes/assets/js/165.80836bd1.js"><link rel="prefetch" href="/my-notes/assets/js/166.7346e59a.js"><link rel="prefetch" href="/my-notes/assets/js/167.5577b6af.js"><link rel="prefetch" href="/my-notes/assets/js/169.ce891665.js"><link rel="prefetch" href="/my-notes/assets/js/17.549cfc80.js"><link rel="prefetch" href="/my-notes/assets/js/170.b4aebdaf.js"><link rel="prefetch" href="/my-notes/assets/js/171.39cdd90b.js"><link rel="prefetch" href="/my-notes/assets/js/172.06cd5671.js"><link rel="prefetch" href="/my-notes/assets/js/173.44c7c161.js"><link rel="prefetch" href="/my-notes/assets/js/174.62d8a34f.js"><link rel="prefetch" href="/my-notes/assets/js/175.baa645ac.js"><link rel="prefetch" href="/my-notes/assets/js/176.8361f852.js"><link rel="prefetch" href="/my-notes/assets/js/177.4a8f2fec.js"><link rel="prefetch" href="/my-notes/assets/js/178.f594def6.js"><link rel="prefetch" href="/my-notes/assets/js/179.2338f129.js"><link rel="prefetch" href="/my-notes/assets/js/18.a8b4f826.js"><link rel="prefetch" href="/my-notes/assets/js/180.1b2f62df.js"><link rel="prefetch" href="/my-notes/assets/js/181.10759f41.js"><link rel="prefetch" href="/my-notes/assets/js/182.c0e1c3c5.js"><link rel="prefetch" href="/my-notes/assets/js/183.bdc8283f.js"><link rel="prefetch" href="/my-notes/assets/js/184.30a6f685.js"><link rel="prefetch" href="/my-notes/assets/js/185.1949079b.js"><link rel="prefetch" href="/my-notes/assets/js/186.bb7c7093.js"><link rel="prefetch" href="/my-notes/assets/js/187.1d02d132.js"><link rel="prefetch" href="/my-notes/assets/js/188.5230fbeb.js"><link rel="prefetch" href="/my-notes/assets/js/189.2931d469.js"><link rel="prefetch" href="/my-notes/assets/js/19.16e1a44c.js"><link rel="prefetch" href="/my-notes/assets/js/190.9bd3b616.js"><link rel="prefetch" href="/my-notes/assets/js/191.d75de9d3.js"><link rel="prefetch" href="/my-notes/assets/js/192.dacb160e.js"><link rel="prefetch" href="/my-notes/assets/js/193.660b4fce.js"><link rel="prefetch" href="/my-notes/assets/js/194.45f8499e.js"><link rel="prefetch" href="/my-notes/assets/js/195.e91d4663.js"><link rel="prefetch" href="/my-notes/assets/js/196.e94176ac.js"><link rel="prefetch" href="/my-notes/assets/js/197.5acbb43f.js"><link rel="prefetch" href="/my-notes/assets/js/198.dc1a1207.js"><link rel="prefetch" href="/my-notes/assets/js/199.288adcec.js"><link rel="prefetch" href="/my-notes/assets/js/20.b19ef4b2.js"><link rel="prefetch" href="/my-notes/assets/js/200.3d318d2e.js"><link rel="prefetch" href="/my-notes/assets/js/21.e3682738.js"><link rel="prefetch" href="/my-notes/assets/js/22.fafa8b54.js"><link rel="prefetch" href="/my-notes/assets/js/23.9d683b40.js"><link rel="prefetch" href="/my-notes/assets/js/24.02c0c08c.js"><link rel="prefetch" href="/my-notes/assets/js/25.af427f02.js"><link rel="prefetch" href="/my-notes/assets/js/26.50a41828.js"><link rel="prefetch" href="/my-notes/assets/js/27.8f1d2fe6.js"><link rel="prefetch" href="/my-notes/assets/js/28.7f820229.js"><link rel="prefetch" href="/my-notes/assets/js/29.208cdce3.js"><link rel="prefetch" href="/my-notes/assets/js/3.32ea0d41.js"><link rel="prefetch" href="/my-notes/assets/js/30.e7a171d3.js"><link rel="prefetch" href="/my-notes/assets/js/31.8ee9f363.js"><link rel="prefetch" href="/my-notes/assets/js/32.b33ae00e.js"><link rel="prefetch" href="/my-notes/assets/js/33.3a961845.js"><link rel="prefetch" href="/my-notes/assets/js/34.46f30eb6.js"><link rel="prefetch" href="/my-notes/assets/js/35.dedda1f7.js"><link rel="prefetch" href="/my-notes/assets/js/36.fb63ded5.js"><link rel="prefetch" href="/my-notes/assets/js/37.321340a9.js"><link rel="prefetch" href="/my-notes/assets/js/38.c21281dd.js"><link rel="prefetch" href="/my-notes/assets/js/39.01776b7e.js"><link rel="prefetch" href="/my-notes/assets/js/4.2466bf2a.js"><link rel="prefetch" href="/my-notes/assets/js/40.c6763f18.js"><link rel="prefetch" href="/my-notes/assets/js/41.afa4c2f3.js"><link rel="prefetch" href="/my-notes/assets/js/42.187357b5.js"><link rel="prefetch" href="/my-notes/assets/js/43.90030eae.js"><link rel="prefetch" href="/my-notes/assets/js/44.e11eff59.js"><link rel="prefetch" href="/my-notes/assets/js/45.760e3e3f.js"><link rel="prefetch" href="/my-notes/assets/js/46.0eccc1a4.js"><link rel="prefetch" href="/my-notes/assets/js/47.30e063f8.js"><link rel="prefetch" href="/my-notes/assets/js/48.5ab681d2.js"><link rel="prefetch" href="/my-notes/assets/js/49.5921c987.js"><link rel="prefetch" href="/my-notes/assets/js/5.56264475.js"><link rel="prefetch" href="/my-notes/assets/js/50.a53fa873.js"><link rel="prefetch" href="/my-notes/assets/js/51.5cded08c.js"><link rel="prefetch" href="/my-notes/assets/js/52.8960c473.js"><link rel="prefetch" href="/my-notes/assets/js/53.2ac21c0e.js"><link rel="prefetch" href="/my-notes/assets/js/54.361bc2f3.js"><link rel="prefetch" href="/my-notes/assets/js/55.3853b7f3.js"><link rel="prefetch" href="/my-notes/assets/js/56.754a3b4c.js"><link rel="prefetch" href="/my-notes/assets/js/57.1d9684e7.js"><link rel="prefetch" href="/my-notes/assets/js/58.0e7f2b60.js"><link rel="prefetch" href="/my-notes/assets/js/59.b37ab2f4.js"><link rel="prefetch" href="/my-notes/assets/js/60.f31d0aea.js"><link rel="prefetch" href="/my-notes/assets/js/61.5aebeb50.js"><link rel="prefetch" href="/my-notes/assets/js/62.cebf26d6.js"><link rel="prefetch" href="/my-notes/assets/js/63.6c7932ca.js"><link rel="prefetch" href="/my-notes/assets/js/64.cad8a013.js"><link rel="prefetch" href="/my-notes/assets/js/65.25e4c14e.js"><link rel="prefetch" href="/my-notes/assets/js/66.e9c81af6.js"><link rel="prefetch" href="/my-notes/assets/js/67.31cbef00.js"><link rel="prefetch" href="/my-notes/assets/js/68.edc93332.js"><link rel="prefetch" href="/my-notes/assets/js/69.5eaf1e4f.js"><link rel="prefetch" href="/my-notes/assets/js/7.5a6eeb6c.js"><link rel="prefetch" href="/my-notes/assets/js/70.7114cd64.js"><link rel="prefetch" href="/my-notes/assets/js/71.2066867c.js"><link rel="prefetch" href="/my-notes/assets/js/72.0f93cb73.js"><link rel="prefetch" href="/my-notes/assets/js/73.6c4d69ec.js"><link rel="prefetch" href="/my-notes/assets/js/74.0a91fc3c.js"><link rel="prefetch" href="/my-notes/assets/js/75.47e45f38.js"><link rel="prefetch" href="/my-notes/assets/js/76.99886a8d.js"><link rel="prefetch" href="/my-notes/assets/js/77.61eb4f51.js"><link rel="prefetch" href="/my-notes/assets/js/78.eff53df7.js"><link rel="prefetch" href="/my-notes/assets/js/79.e5d77573.js"><link rel="prefetch" href="/my-notes/assets/js/8.c2fa6f68.js"><link rel="prefetch" href="/my-notes/assets/js/80.8ac4e931.js"><link rel="prefetch" href="/my-notes/assets/js/81.82416621.js"><link rel="prefetch" href="/my-notes/assets/js/82.b7cea701.js"><link rel="prefetch" href="/my-notes/assets/js/83.eb0065f7.js"><link rel="prefetch" href="/my-notes/assets/js/84.45596ac9.js"><link rel="prefetch" href="/my-notes/assets/js/85.73902eef.js"><link rel="prefetch" href="/my-notes/assets/js/86.05a157f2.js"><link rel="prefetch" href="/my-notes/assets/js/87.83218f21.js"><link rel="prefetch" href="/my-notes/assets/js/88.bf05ee49.js"><link rel="prefetch" href="/my-notes/assets/js/89.089b5c96.js"><link rel="prefetch" href="/my-notes/assets/js/9.4a5b4024.js"><link rel="prefetch" href="/my-notes/assets/js/90.dc0b55a6.js"><link rel="prefetch" href="/my-notes/assets/js/91.ddc7da4f.js"><link rel="prefetch" href="/my-notes/assets/js/92.2b5c7d5f.js"><link rel="prefetch" href="/my-notes/assets/js/93.934a02e9.js"><link rel="prefetch" href="/my-notes/assets/js/94.3a6ede23.js"><link rel="prefetch" href="/my-notes/assets/js/95.0e946220.js"><link rel="prefetch" href="/my-notes/assets/js/96.3861fb05.js"><link rel="prefetch" href="/my-notes/assets/js/97.8627cefa.js"><link rel="prefetch" href="/my-notes/assets/js/98.6e0ee750.js"><link rel="prefetch" href="/my-notes/assets/js/99.5df99b25.js">
    <link rel="stylesheet" href="/my-notes/assets/css/0.styles.565c6041.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my-notes/" class="home-link router-link-active"><img src="/my-notes/img/logo.jpg" alt="DK's Notes" class="logo"> <span class="site-name can-hide">DK's Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my-notes/" class="nav-link">首页</a></div><div class="nav-item"><a href="/my-notes/about/website/tools/" class="nav-link">导航站</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/my-notes/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java-Se</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/java/se/base/" class="nav-link">Java基础</a></li></ul></li><li class="dropdown-item"><h4>Java-Se进阶-多线程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/java/se/thread/" class="nav-link">多线程</a></li></ul></li><li class="dropdown-item"><h4>Java-Se进阶-java8新特性</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/java/se/java8/" class="nav-link">java8新特性</a></li></ul></li><li class="dropdown-item"><h4>Java-ee</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/javaweb/" class="nav-link">JavaWeb</a></li></ul></li><li class="dropdown-item"><h4>Java虚拟机</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/JVM/" class="nav-link">JVM</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/my-notes/mysql/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>SQL 数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/mysql/" class="nav-link">MySQL</a></li></ul></li><li class="dropdown-item"><h4>NoSQL 数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/redis/" class="nav-link">Redis</a></li><li class="dropdown-subitem"><a href="/my-notes/es/" class="nav-link">ElasticSearch</a></li><li class="dropdown-subitem"><a href="/my-notes/mongodb/" class="nav-link">MongoDB</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><a href="/my-notes/mybatis/study-note/" class="link-title">框架</a> <span class="title" style="display:none;">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>ORM</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/mybatis/study-note/" class="nav-link">MyBatis</a></li><li class="dropdown-subitem"><a href="/my-notes/mybatis-plus/study-note/" class="nav-link">MyBatis-Plus</a></li></ul></li><li class="dropdown-item"><h4>Spring</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/Spring/study-note/" class="nav-link">Spring</a></li></ul></li><li class="dropdown-item"><h4>SpringMVC</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/SpringMvc/study-note/1/" class="nav-link">SpringMVC1</a></li><li class="dropdown-subitem"><a href="/my-notes/SpringMvc/study-note/2/" class="nav-link">SpringMVC2</a></li></ul></li><li class="dropdown-item"><h4>SpringCloud</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/SpringCloud/" class="nav-link">SpringCloud</a></li></ul></li><li class="dropdown-item"><h4>中间件</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/rabbitmq/" class="nav-link">RabbitMQ</a></li><li class="dropdown-subitem"><a href="/my-notes/dubbo/" class="nav-link">Dubbo</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/my-notes/project/seckill/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-notes/project/seckill/" class="nav-link">秒杀项目</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具|部署" class="dropdown-title"><a href="/my-notes/git/" class="link-title">工具|部署</a> <span class="title" style="display:none;">工具|部署</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-notes/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/my-notes/Linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/my-notes/Docker/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/my-notes/JWT/note/" class="nav-link">JWT</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试|刷题" class="dropdown-title"><a href="/my-notes/work/interview/" class="link-title router-link-active">面试|刷题</a> <span class="title" style="display:none;">面试|刷题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-notes/work/interview/" class="nav-link router-link-active">面试</a></li><li class="dropdown-item"><!----> <a href="/my-notes/work/algorithm/" class="nav-link">刷题</a></li></ul></div></div><div class="nav-item"><a href="/my-notes/dev/question/" class="nav-link">开发问题😈</a></div><div class="nav-item"><a href="/my-notes/designPattern/" class="nav-link">设计模式</a></div><div class="nav-item"><a href="/my-notes/about/" class="nav-link">关于💕</a></div><div class="nav-item"><a href="/my-notes/archives/" class="nav-link">归档🕛</a></div> <a href="https://github.com/hnistzdk/my-notes" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.jpg"> <div class="blogger-info"><h3>风</h3> <span>摸鱼</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/my-notes/" class="nav-link">首页</a></div><div class="nav-item"><a href="/my-notes/about/website/tools/" class="nav-link">导航站</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/my-notes/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java-Se</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/java/se/base/" class="nav-link">Java基础</a></li></ul></li><li class="dropdown-item"><h4>Java-Se进阶-多线程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/java/se/thread/" class="nav-link">多线程</a></li></ul></li><li class="dropdown-item"><h4>Java-Se进阶-java8新特性</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/java/se/java8/" class="nav-link">java8新特性</a></li></ul></li><li class="dropdown-item"><h4>Java-ee</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/javaweb/" class="nav-link">JavaWeb</a></li></ul></li><li class="dropdown-item"><h4>Java虚拟机</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/JVM/" class="nav-link">JVM</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/my-notes/mysql/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>SQL 数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/mysql/" class="nav-link">MySQL</a></li></ul></li><li class="dropdown-item"><h4>NoSQL 数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/redis/" class="nav-link">Redis</a></li><li class="dropdown-subitem"><a href="/my-notes/es/" class="nav-link">ElasticSearch</a></li><li class="dropdown-subitem"><a href="/my-notes/mongodb/" class="nav-link">MongoDB</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><a href="/my-notes/mybatis/study-note/" class="link-title">框架</a> <span class="title" style="display:none;">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>ORM</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/mybatis/study-note/" class="nav-link">MyBatis</a></li><li class="dropdown-subitem"><a href="/my-notes/mybatis-plus/study-note/" class="nav-link">MyBatis-Plus</a></li></ul></li><li class="dropdown-item"><h4>Spring</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/Spring/study-note/" class="nav-link">Spring</a></li></ul></li><li class="dropdown-item"><h4>SpringMVC</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/SpringMvc/study-note/1/" class="nav-link">SpringMVC1</a></li><li class="dropdown-subitem"><a href="/my-notes/SpringMvc/study-note/2/" class="nav-link">SpringMVC2</a></li></ul></li><li class="dropdown-item"><h4>SpringCloud</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/SpringCloud/" class="nav-link">SpringCloud</a></li></ul></li><li class="dropdown-item"><h4>中间件</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/my-notes/rabbitmq/" class="nav-link">RabbitMQ</a></li><li class="dropdown-subitem"><a href="/my-notes/dubbo/" class="nav-link">Dubbo</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/my-notes/project/seckill/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-notes/project/seckill/" class="nav-link">秒杀项目</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具|部署" class="dropdown-title"><a href="/my-notes/git/" class="link-title">工具|部署</a> <span class="title" style="display:none;">工具|部署</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-notes/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/my-notes/Linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/my-notes/Docker/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/my-notes/JWT/note/" class="nav-link">JWT</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试|刷题" class="dropdown-title"><a href="/my-notes/work/interview/" class="link-title router-link-active">面试|刷题</a> <span class="title" style="display:none;">面试|刷题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/my-notes/work/interview/" class="nav-link router-link-active">面试</a></li><li class="dropdown-item"><!----> <a href="/my-notes/work/algorithm/" class="nav-link">刷题</a></li></ul></div></div><div class="nav-item"><a href="/my-notes/dev/question/" class="nav-link">开发问题😈</a></div><div class="nav-item"><a href="/my-notes/designPattern/" class="nav-link">设计模式</a></div><div class="nav-item"><a href="/my-notes/about/" class="nav-link">关于💕</a></div><div class="nav-item"><a href="/my-notes/archives/" class="nav-link">归档🕛</a></div> <a href="https://github.com/hnistzdk/my-notes" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/my-notes/work/interview/" aria-current="page" class="sidebar-link">纲要</a></li><li><a href="/my-notes/work/interview/java/" class="sidebar-link">java基础</a></li><li><a href="/my-notes/work/interview/os/" class="sidebar-link">操作系统</a></li><li><a href="/my-notes/work/interview/network/" aria-current="page" class="active sidebar-link">网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#思维导图" class="sidebar-link">思维导图</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#重点" class="sidebar-link">重点</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_1-tcp三次握手" class="sidebar-link">1.TCP三次握手</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_1-1为什么需要三次握手-两次不行吗" class="sidebar-link">1.1为什么需要三次握手，两次不行吗？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_1-2-什么是半连接队列" class="sidebar-link">1.2 什么是半连接队列？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_1-3-isn-initial-sequence-number-是固定的吗" class="sidebar-link">1.3 ISN(Initial Sequence Number)是固定的吗？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_1-4-三次握手过程中可以携带数据吗" class="sidebar-link">1.4 三次握手过程中可以携带数据吗？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_1-5-syn攻击是什么" class="sidebar-link">1.5 SYN攻击是什么？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_2-tcp四次挥手" class="sidebar-link">2.TCP四次挥手</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_2-1-挥手为什么需要四次" class="sidebar-link">2.1 挥手为什么需要四次？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_2-2-2msl等待状态" class="sidebar-link">2.2 2MSL等待状态</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_2-3-四次挥手释放连接时-等待2msl的意义" class="sidebar-link">2.3 四次挥手释放连接时，等待2MSL的意义？</a></li><li class="sidebar-sub-header level4"><a href="/my-notes/work/interview/network/#两个理由" class="sidebar-link">两个理由：</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_2-4-服务器端的保活计时器" class="sidebar-link">2.4 服务器端的保活计时器</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_2-5-为什么time-wait状态需要经过2msl才能返回到close状态" class="sidebar-link">2.5 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_2-6-tcp状态变迁图" class="sidebar-link">2.6 TCP状态变迁图</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_2-7-tcp报文段的首部格式" class="sidebar-link">2.7 TCP报文段的首部格式</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_3-tcp和udp是什么" class="sidebar-link">3.TCP和UDP是什么</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_4-tcp和udp有什么区别" class="sidebar-link">4.TCP和UDP有什么区别</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_5-tcp维护可靠的通信方式" class="sidebar-link">5.TCP维护可靠的通信方式</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_6-tcp-ip的流量控制" class="sidebar-link">6.TCP/IP的流量控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_6-1-滑动窗口机制" class="sidebar-link">6.1 滑动窗口机制</a></li><li class="sidebar-sub-header level4"><a href="/my-notes/work/interview/network/#过程举例" class="sidebar-link">过程举例</a></li><li class="sidebar-sub-header level4"><a href="/my-notes/work/interview/network/#为什么接收窗口大小为0-还能接收零窗口探测报文段" class="sidebar-link">为什么接收窗口大小为0，还能接收零窗口探测报文段？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_6-2-传递效率" class="sidebar-link">6.2 传递效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_7-拥塞控制" class="sidebar-link">7.拥塞控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_7-1-什么是拥塞-什么是拥塞控制" class="sidebar-link">7.1 什么是拥塞？什么是拥塞控制？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_7-2-检测网络拥塞的方法" class="sidebar-link">7.2 检测网络拥塞的方法？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_7-3-网络拥塞的表现" class="sidebar-link">7.3 网络拥塞的表现？</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_7-4-tcp-ip协议的拥塞控制" class="sidebar-link">7.4 TCP/IP协议的拥塞控制？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_8-arp是地址解析协议-简单解释下工作原理" class="sidebar-link">8.ARP是地址解析协议，简单解释下工作原理</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_9-icmp协议" class="sidebar-link">9.ICMP协议</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_10-dhcp协议" class="sidebar-link">10.DHCP协议</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_11-ttl是什么-作用是什么-哪些工具会用到它" class="sidebar-link">11.TTL是什么？作用是什么？哪些工具会用到它?</a></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_12-web页面的请求过程" class="sidebar-link">12.web页面的请求过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-1-查找-dns-缓存" class="sidebar-link">12.1 查找 DNS 缓存</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-2-发起-dns-查询" class="sidebar-link">12.2 发起 DNS 查询</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-3-arp-请求" class="sidebar-link">12.3 ARP 请求</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-4-封装-tcp-数据包" class="sidebar-link">12.4 封装 TCP 数据包</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-5-浏览器与目标服务器建立-tcp-连接" class="sidebar-link">12.5 浏览器与目标服务器建立 TCP 连接</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-6-浏览器发送-http-请求到-web-服务器" class="sidebar-link">12.6 浏览器发送 HTTP 请求到 web 服务器</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-7-服务器处理请求并发回一个响应" class="sidebar-link">12.7 服务器处理请求并发回一个响应</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-8-服务器发送回一个-http-响应" class="sidebar-link">12.8 服务器发送回一个 HTTP 响应</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_12-9-浏览器显示-html-的相关内容" class="sidebar-link">12.9 浏览器显示 HTML 的相关内容</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/my-notes/work/interview/network/#_13-dns-domain-name-system" class="sidebar-link">13.DNS(Domain Name System)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_13-1概要" class="sidebar-link">13.1概要</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_13-2域名结构" class="sidebar-link">13.2域名结构：</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_13-3域名空间" class="sidebar-link">13.3域名空间：</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_13-4域名划分" class="sidebar-link">13.4域名划分</a></li><li class="sidebar-sub-header level3"><a href="/my-notes/work/interview/network/#_13-5域名解析的过程" class="sidebar-link">13.5域名解析的过程</a></li></ul></li></ul></li><li><a href="/my-notes/work/interview/framework/" class="sidebar-link">框架</a></li><li><a href="/my-notes/work/interview/thread/" class="sidebar-link">多线程、并发</a></li><li><a href="/my-notes/work/interview/http(s)/" class="sidebar-link">HTTP、HTTPS</a></li><li><a href="/my-notes/work/interview/MySQL/" class="sidebar-link">MySQL</a></li><li><a href="/my-notes/work/interview/question/" class="sidebar-link">一些面经里的面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>刷题</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/my-notes/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/my-notes/categories/?category=%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98" title="分类" data-v-06225672>面试刷题</a></li><li data-v-06225672><a href="/my-notes/categories/?category=%E9%9D%A2%E8%AF%95" title="分类" data-v-06225672>面试</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://www.zaiolos.top/" target="_blank" title="作者" class="beLink" data-v-06225672>zdk</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-02-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">网络<!----></h1> <!----> <div class="theme-vdoing-content content__default"><p><strong>Table of Contents</strong> <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener noreferrer">DocToc<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></em></p> <ul><li><a href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE">思维导图</a></li> <li><a href="#%E9%87%8D%E7%82%B9">重点</a></li> <li><a href="#1tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">1.TCP三次握手</a> <ul><li><a href="#11%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97">1.1为什么需要三次握手，两次不行吗？</a></li> <li><a href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97">1.2 什么是半连接队列？</a></li> <li><a href="#13-isninitial-sequence-number%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97">1.3 ISN(Initial Sequence Number)是固定的吗？</a></li> <li><a href="#14-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97">1.4 三次握手过程中可以携带数据吗？</a></li> <li><a href="#15-syn%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88">1.5 SYN攻击是什么？</a></li></ul></li> <li><a href="#2tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">2.TCP四次挥手</a> <ul><li><a href="#21-%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1">2.1 挥手为什么需要四次？</a></li> <li><a href="#22-2msl%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81">2.2 2MSL等待状态</a></li> <li><a href="#23-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%AD%89%E5%BE%852msl%E7%9A%84%E6%84%8F%E4%B9%89">2.3 四次挥手释放连接时，等待2MSL的意义？</a> <ul><li><a href="#%E4%B8%A4%E4%B8%AA%E7%90%86%E7%94%B1">两个理由：</a></li></ul></li> <li><a href="#24-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%97%B6%E5%99%A8">2.4 服务器端的保活计时器</a></li> <li><a href="#25-%E4%B8%BA%E4%BB%80%E4%B9%88time_wait%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%872msl%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0close%E7%8A%B6%E6%80%81">2.5 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</a></li> <li><a href="#26-tcp%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81%E5%9B%BE">2.6 TCP状态变迁图</a></li> <li><a href="#27-tcp%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">2.7 TCP报文段的首部格式</a></li></ul></li> <li><a href="#3tcp%E5%92%8Cudp%E6%98%AF%E4%BB%80%E4%B9%88">3.TCP和UDP是什么</a></li> <li><a href="#4tcp%E5%92%8Cudp%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">4.TCP和UDP有什么区别</a></li> <li><a href="#5tcp%E7%BB%B4%E6%8A%A4%E5%8F%AF%E9%9D%A0%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">5.TCP维护可靠的通信方式</a></li> <li><a href="#6tcpip%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">6.TCP/IP的流量控制</a> <ul><li><a href="#61-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6">6.1 滑动窗口机制</a> <ul><li><a href="#%E8%BF%87%E7%A8%8B%E4%B8%BE%E4%BE%8B">过程举例</a></li> <li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%B8%BA0%E8%BF%98%E8%83%BD%E6%8E%A5%E6%94%B6%E9%9B%B6%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B%E6%8A%A5%E6%96%87%E6%AE%B5">为什么接收窗口大小为0，还能接收零窗口探测报文段？</a></li></ul></li> <li><a href="#62-%E4%BC%A0%E9%80%92%E6%95%88%E7%8E%87">6.2 传递效率</a></li></ul></li> <li><a href="#7%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">7.拥塞控制</a> <ul><li><a href="#71-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A5%E5%A1%9E%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">7.1 什么是拥塞？什么是拥塞控制？</a></li> <li><a href="#72-%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E7%9A%84%E6%96%B9%E6%B3%95">7.2 检测网络拥塞的方法？</a></li> <li><a href="#73-%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E7%9A%84%E8%A1%A8%E7%8E%B0">7.3 网络拥塞的表现？</a></li> <li><a href="#74-tcpip%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">7.4 TCP/IP协议的拥塞控制？</a></li></ul></li> <li><a href="#8arp%E6%98%AF%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E4%B8%8B%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">8.ARP是地址解析协议，简单解释下工作原理</a></li> <li><a href="#9icmp%E5%8D%8F%E8%AE%AE">9.ICMP协议</a></li> <li><a href="#10dhcp%E5%8D%8F%E8%AE%AE">10.DHCP协议</a></li> <li><a href="#11ttl%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7%E4%BC%9A%E7%94%A8%E5%88%B0%E5%AE%83">11.TTL是什么？作用是什么？哪些工具会用到它?</a></li> <li><a href="#12web%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">12.web页面的请求过程</a> <ul><li><a href="#121-%E6%9F%A5%E6%89%BE-dns-%E7%BC%93%E5%AD%98">12.1 查找 DNS 缓存</a></li> <li><a href="#122-%E5%8F%91%E8%B5%B7-dns-%E6%9F%A5%E8%AF%A2">12.2 发起 DNS 查询</a></li> <li><a href="#123-arp-%E8%AF%B7%E6%B1%82">12.3 ARP 请求</a></li> <li><a href="#124-%E5%B0%81%E8%A3%85-tcp-%E6%95%B0%E6%8D%AE%E5%8C%85">12.4 封装 TCP 数据包</a></li> <li><a href="#125-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5">12.5 浏览器与目标服务器建立 TCP 连接</a></li> <li><a href="#126-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82%E5%88%B0-web-%E6%9C%8D%E5%8A%A1%E5%99%A8">12.6 浏览器发送 HTTP 请求到 web 服务器</a></li> <li><a href="#127-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%8F%91%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%93%8D%E5%BA%94">12.7 服务器处理请求并发回一个响应</a></li> <li><a href="#128-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E5%9B%9E%E4%B8%80%E4%B8%AA-http-%E5%93%8D%E5%BA%94">12.8 服务器发送回一个 HTTP 响应</a></li> <li><a href="#129-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA-html-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">12.9 浏览器显示 HTML 的相关内容</a></li></ul></li> <li><a href="#13dnsdomain-name-system">13.DNS(Domain Name System)</a> <ul><li><a href="#131%E6%A6%82%E8%A6%81">13.1概要</a></li> <li><a href="#132%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84">13.2域名结构：</a></li> <li><a href="#133%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4">13.3域名空间：</a></li> <li><a href="#134%E5%9F%9F%E5%90%8D%E5%88%92%E5%88%86">13.4域名划分</a></li> <li><a href="#135%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B">13.5域名解析的过程</a></li></ul></li></ul> <hr> <h2 id="思维导图"><a href="#思维导图" class="header-anchor">#</a> 思维导图</h2> <iframe src="https://gitmind.cn/app/doc/9b37226931" width="100%" height="500" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe> <h2 id="重点"><a href="#重点" class="header-anchor">#</a> 重点</h2> <ol><li>TCP/IP协议体系的认知</li> <li>链路层
<ol><li>以太网帧的格式</li> <li>MTU的概念</li> <li>ARP协议和RARP协议（掌握一下ARP缓存的原理）</li></ol></li> <li>网络层
<ol><li>掌握IP的首部格式</li> <li>掌握IP的分片</li> <li>掌握IP选路</li> <li>ICMP协议
<ol><li>掌握报文格式</li> <li>分类：查询 + 差错</li> <li>两种 + 五种</li></ol></li></ol></li> <li>传输层
<ol><li>UDP，次要一点，掌握特点和首部各个字段</li> <li>掌握TCP
<ol><li>特点 + 首部字段 + 可靠机制</li> <li>连接控制 ： 三次握手，四次挥手，同时打开，同时关闭，半关闭（可能问到为什么需要）</li> <li>流量控制机制：滑动窗口,慢启动，拥塞避免，快速重传，快速恢复</li> <li>超时重传机制：各种定时器</li></ol></li></ol></li> <li>应用层
<ol><li>掌握DNS协议
<ol><li>名字空间</li> <li>指针查询（反向查找或逆向解析）基本原理</li> <li>DNS缓存</li></ol></li> <li>FTP协议（活化石）：
<ol><li>控制流和数据流</li> <li>两种工作模式： PASV 和 PORT</li> <li>各种指令和响应码</li> <li>断点续传和匿名FTP的概念</li></ol></li> <li>HTTP协议：
<ol><li>报文格式：请求报文，响应报文，请求头各种字段，响应头各种字段</li> <li>HTTP状态码</li></ol></li> <li>HTTPS协议
<ol><li>握手的详细过程</li> <li>摘要算法，数字签名，数字证书的原理和过程</li></ol></li></ol></li></ol> <h2 id="_1-tcp三次握手"><a href="#_1-tcp三次握手" class="header-anchor">#</a> 1.TCP三次握手</h2> <p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p> <p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。
进行三次握手：</p> <ul><li><p>第一次握手：(<code>客户端给服务器发送TCP连接请求</code>)客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。</p> <p>首部的同步位SYN=1，初始序号seq=x，<code>TCP的标准规定，SYN=1的报文段不能携带数据，但要消耗掉一个序号</code>。</p></li> <li><p>第二次握手：(<code>服务器给客户端发送针对TCP连接请求的确认</code>)服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于<code>SYN_RCVD</code>的状态。</p> <p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p></li> <li><p>第三次握手：(<code>客户端给服务器发送针对TCP连接请求的确认的确认</code>)客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于<code>ESTABLISHED</code>状态。服务器收到 ACK 报文之后，也处于<code>ESTABLISHED</code>状态，此时，双方已建立起了连接。</p> <p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p> <p><code>TCP的标准规定，普通的确认报文，如果不携带数据，则不消耗序号</code></p></li></ul> <p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p> <p>在socket编程中，客户端执行connect()时，将触发三次握手。</p> <p><strong>下图中服务器发送给客户端的确认报文中，服务端的初始序号seq=y，可由服务端随机指定，与其他报文段中的值无关</strong></p> <p><img src="https://images.zaiolos.top/images/202203082124618.png" alt="image-20220308212459522"></p> <h3 id="_1-1为什么需要三次握手-两次不行吗"><a href="#_1-1为什么需要三次握手-两次不行吗" class="header-anchor">#</a> 1.1为什么需要三次握手，两次不行吗？</h3> <p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p> <ul><li><p>第一次握手：客户端发送网络包，服务端收到了。
这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p></li> <li><p>第二次握手：服务端发包，客户端收到了。
这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p></li> <li><p>第三次握手：客户端发包，服务端收到了。
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p> <p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p></li></ul> <p>试想如果是用两次握手，则会出现下面这种情况：</p> <blockquote><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<code>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</code>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></blockquote> <p><code>所以不采用两次握手是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致服务器长时间等待，浪费资源</code></p> <h3 id="_1-2-什么是半连接队列"><a href="#_1-2-什么是半连接队列" class="header-anchor">#</a> 1.2 什么是半连接队列？</h3> <p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<code>队列</code>里，我们把这种队列称之为<code>半连接队列</code>。</p> <p>当然还有一个<code>全连接队列</code>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p> <p>这里在补充一点关于<code>SYN-ACK 重传次数</code>的问题：
服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p> <h3 id="_1-3-isn-initial-sequence-number-是固定的吗"><a href="#_1-3-isn-initial-sequence-number-是固定的吗" class="header-anchor">#</a> 1.3 ISN(Initial Sequence Number)是固定的吗？</h3> <p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p> <p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></p> <h3 id="_1-4-三次握手过程中可以携带数据吗"><a href="#_1-4-三次握手过程中可以携带数据吗" class="header-anchor">#</a> 1.4 三次握手过程中可以携带数据吗？</h3> <p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</p> <p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p> <p>也就是说，<strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p> <h3 id="_1-5-syn攻击是什么"><a href="#_1-5-syn攻击是什么" class="header-anchor">#</a> 1.5 SYN攻击是什么？</h3> <blockquote><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p></blockquote> <p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstat 命令来检测 SYN 攻击。</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">netstat</span> <span class="token parameter variable">-n</span> <span class="token parameter variable">-p</span> TCP <span class="token operator">|</span> <span class="token function">grep</span> SYN_RECV
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>常见的防御 SYN 攻击的方法有如下几种：</p> <ul><li>缩短超时（SYN Timeout）时间</li> <li>增加最大半连接数</li> <li>过滤网关防护</li> <li>SYN cookies技术</li></ul> <h2 id="_2-tcp四次挥手"><a href="#_2-tcp四次挥手" class="header-anchor">#</a> 2.TCP四次挥手</h2> <p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p> <p>TCP 连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。</p> <p>刚开始双方都处于<code>ESTABLISHED</code>状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p> <ul><li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
即发出<code>连接释放报文段</code>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入<code>FIN_WAIT1</code>（终止等待1）状态，等待服务端的确认。</p> <p><code>序号seq=u中的u等于TCP客户进程之前传送过的数据的最后一个字节+1</code></p> <p><code>TCP规定，终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</code></p> <p><code>ack字段的值v等于客户进程之前已收到的数据的最后一个字节的序号+1</code>(等于服务器进程传送过的数据的最后一个字节)</p></li> <li><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于<code>CLOSE_WAIT</code>状态。
即服务端收到连接释放报文段后即发出<code>确认报文段</code>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入<code>CLOSE_WAIT</code>（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待2）状态，等待服务端发出的连接释放报文段。</p> <p><code>seq=v中的v等于TCP服务器进程之前已传送过的数据的最后一个字节的序号+1</code></p> <p><code>ack=u+1中的u等于TCP服务器进程之前已收到的数据的最后一个字节的序号+1</code></p></li> <li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。
即服务端没有要向客户端发出的数据，服务端发出<code>连接释放报文段</code>（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入<code>LAST_ACK</code>（最后确认）状态，等待客户端的确认。</p></li> <li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于<code>TIME_WAIT</code>状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <code>CLOSED</code> 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于<code>CLOSED</code> 状态。
即客户端收到服务端的连接释放报文段后，对此发出<code>确认报文段</code>（ACK=1，seq=u+1，ack=w+1），客户端进入<code>TIME_WAIT</code>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入<code>CLOSED</code>状态。</p></li></ul> <p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p> <p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p> <p><img src="https://images.zaiolos.top/images/202203082117725.png" alt="image-20220308211717617"></p> <h3 id="_2-1-挥手为什么需要四次"><a href="#_2-1-挥手为什么需要四次" class="header-anchor">#</a> 2.1 挥手为什么需要四次？</h3> <p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p> <h3 id="_2-2-2msl等待状态"><a href="#_2-2-2msl等待状态" class="header-anchor">#</a> 2.2 2MSL等待状态</h3> <p>如果客户端不等待，而是直接关闭，会导致以下情况</p> <p><img src="https://images.zaiolos.top/images/202203082120301.png" alt="image-20220308212041201"></p> <blockquote><p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote> <blockquote><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p> <p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p> <p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p></blockquote> <h3 id="_2-3-四次挥手释放连接时-等待2msl的意义"><a href="#_2-3-四次挥手释放连接时-等待2msl的意义" class="header-anchor">#</a> 2.3 四次挥手释放连接时，等待2MSL的意义？</h3> <blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p></blockquote> <h4 id="两个理由"><a href="#两个理由" class="header-anchor">#</a> 两个理由：</h4> <ol><li><p><strong>保证客户端发送的最后一个ACK报文段能够到达服务端</strong>。</p> <blockquote><p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p></blockquote></li> <li><p><strong>防止“已失效的连接请求报文段”出现在本连接中</strong>。</p> <blockquote><p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p></blockquote></li></ol> <h3 id="_2-4-服务器端的保活计时器"><a href="#_2-4-服务器端的保活计时器" class="header-anchor">#</a> 2.4 服务器端的保活计时器</h3> <p><img src="https://images.zaiolos.top/images/202203082123458.png" alt="image-20220308212339364"></p> <h3 id="_2-5-为什么time-wait状态需要经过2msl才能返回到close状态"><a href="#_2-5-为什么time-wait状态需要经过2msl才能返回到close状态" class="header-anchor">#</a> 2.5 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h3> <blockquote><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。</p></blockquote> <h3 id="_2-6-tcp状态变迁图"><a href="#_2-6-tcp状态变迁图" class="header-anchor">#</a> 2.6 TCP状态变迁图</h3> <p><img src="https://images.zaiolos.top/images/202203052006278.png" alt="TCP状态变迁图.jpg"></p> <h3 id="_2-7-tcp报文段的首部格式"><a href="#_2-7-tcp报文段的首部格式" class="header-anchor">#</a> 2.7 TCP报文段的首部格式</h3> <ul><li>为了实现可靠传输，TCP采用了面向字节流的方式</li> <li>但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送
<ul><li>一个TCP报文段由<code>首部</code>和<code>数据载荷</code>两部分构成</li> <li>TCP的全部功能都体现在它首部中各字段的作用</li></ul></li></ul> <p><img src="https://images.zaiolos.top/images/202203121425001.png" alt="image-20220312142545944"></p> <p><code>首部格式：</code></p> <p><img src="https://images.zaiolos.top/images/202203121427060.png" alt="image-20220312142722984"></p> <ul><li><p><img src="https://images.zaiolos.top/images/202203121430549.png" alt="image-20220312143047489"></p></li> <li><p><img src="https://images.zaiolos.top/images/202203121431638.png" alt="image-20220312143140576"></p></li> <li><p><img src="https://images.zaiolos.top/images/202203121432739.png" alt="image-20220312143214688"></p></li> <li><p><img src="https://images.zaiolos.top/images/202203121435548.png" alt="image-20220312143547485"></p></li> <li><p><strong>保留</strong>：占6比特，保留为今后使用，但目前应置为零</p></li> <li><p><img src="https://images.zaiolos.top/images/202203121439692.png" alt="image-20220312143924628"></p> <p><code>应从接收窗口和拥塞窗口中取小者</code></p></li> <li><p>校验和(不重要)：占16比特，用来检查整个TCP报文段在传输过程中是否出现了误码，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</p></li> <li><p><img src="https://images.zaiolos.top/images/202203121446619.png" alt="image-20220312144619560"></p></li> <li><p><img src="https://images.zaiolos.top/images/202203121447428.png" alt="image-20220312144705358"></p></li> <li><p><img src="https://images.zaiolos.top/images/202203121447174.png" alt="image-20220312144741114"></p></li> <li><p><img src="https://images.zaiolos.top/images/202203121448529.png" alt="image-20220312144810474"></p></li> <li><p><img src="https://images.zaiolos.top/images/202203121449748.png" alt="image-20220312144914659"></p> <p>接收方收到紧急标志为1的报文段，会按照紧急指针字段的值，从报文段数据载荷部分取出紧急数据，并直接上交给应用进程，而不必在接收缓存中排队</p></li> <li><p><img src="https://images.zaiolos.top/images/202203121456224.png" alt="image-20220312145657165"></p></li> <li><p><img src="https://images.zaiolos.top/images/202203121457504.png" alt="image-20220312145722446"></p></li></ul> <h2 id="_3-tcp和udp是什么"><a href="#_3-tcp和udp是什么" class="header-anchor">#</a> 3.TCP和UDP是什么</h2> <blockquote><p>TCP：
传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。</p></blockquote> <blockquote><p>UDP：
Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。</p></blockquote> <h2 id="_4-tcp和udp有什么区别"><a href="#_4-tcp和udp有什么区别" class="header-anchor">#</a> 4.TCP和UDP有什么区别</h2> <p><img src="https://images.zaiolos.top/images/202203082126567.png" alt="image-20220308212601476"></p> <ol><li><p><code>TCP面向连接，通过三次握手建立连接，四次挥手接除连接</code>;<code>UDP是无连接的，即发送数据之前不需要建立连接</code>，这种方式为UDP带来了高效的传输效率，但也导致无法确保数据的发送成功。</p></li> <li><p><code>TCP是可靠的通信方式</code>。通过TCP连接传送的数据，TCP通过超时重传、 数据校验等方式来确保数据无差错，不丢失，不重复，且按序到达；而UDP由于无需连接的原因，将会以最大速度进行传输，<code>但不保证可靠交付，也就是会出现丢失、重复等等问题</code>。</p></li> <li><p><code>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流</code>，由于连接的问题，当网络出现波动时，连接可能出现响应问题；<code>UDP对应用进程交下来的报文既不合并也不拆分，即UDP是面向应用报文的</code>,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</p> <p><img src="https://images.zaiolos.top/images/202203082138273.png" alt="image-20220308213813176"></p></li> <li><p><code>每一条TCP连接只能是点到点的</code>；而UDP不建立连接，所以可以支持<code>一对一，一对多，多对一和多对多</code>的交互通信，也就是可以同时接受多个人的包。</p></li> <li><p>TCP需要建立连接，<code>首部开销</code>20字节相比8个字节的UDP显得比较大。</p> <p><img src="https://images.zaiolos.top/images/202203121158521.png" alt="image-20220312115845431"></p></li> <li><p>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</p> <p><img src="https://images.zaiolos.top/images/202203121157180.png" alt="image-20220312115732021"></p></li></ol> <h2 id="_5-tcp维护可靠的通信方式"><a href="#_5-tcp维护可靠的通信方式" class="header-anchor">#</a> 5.TCP维护可靠的通信方式</h2> <ol><li>数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；</li> <li>到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认包；</li> <li>超时重发：发送方在发送分片后计时，若超时却没有收到相应的确认包，将会重发对应的分片；</li> <li>滑动窗口：TCP连接双方的接收缓冲空间大小都固定，接收端只能接受缓冲区能接纳的数据。</li> <li>失序处理：TCP的接收端需要重新排序接收到的数据。</li> <li>重复处理：如果传输的TCP分片出现重复，TCP的接收端需要丢弃重复的数据。</li> <li>数据校验：TCP通过保持它首部和数据的检验和来检测数据在传输过程中的任何变化。</li></ol> <h2 id="_6-tcp-ip的流量控制"><a href="#_6-tcp-ip的流量控制" class="header-anchor">#</a> 6.TCP/IP的流量控制</h2> <ol><li><p>需要流量控制的原因</p> <blockquote><p>数据发送的过快接受放来不及接受会造成数据丢失</p></blockquote></li> <li><p>如何控制</p> <blockquote><p>让发送方的发生速率不要太快，接收方来得及接受</p></blockquote></li> <li><p>具体：利用滑动窗口机制</p> <ul><li>由接收方控制流量，收到的数据会发送确认，确认之后发送方的窗口会向前滑动发送接下来的字节</li> <li>当接收方没有内存会告诉发送方能接受的字节为0 ，但是这个消息可能会丢失，丢失之后发送方和接收方都会一直等待对方发送数据，会形成死锁</li> <li>首先如果接收方收到0字节通知会启动一个持续计时器，计时器超时的话会发送一个0窗口探测报文，发送方收到就会返回自己现在能接受的数据大小，死锁解除，如果还是0就再开启一个计时器</li> <li>如果零窗口探测报文丢失的话，也有一个计时器，这个计时器超时探测报文也会重传</li></ul></li></ol> <h3 id="_6-1-滑动窗口机制"><a href="#_6-1-滑动窗口机制" class="header-anchor">#</a> 6.1 滑动窗口机制</h3> <p><strong>滑动窗口通俗来讲就是一种流量控制技术</strong></p> <p><strong>它本质上是描述接收方的TCP数据报缓冲区大小的数据</strong>，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来</p> <p>所谓滑动窗口协议，自己理解有两点：1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。在引入一个例子来说这个协议之前，我觉得很有必要先了解以下前提：</p> <ol><li>TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收），我们以A发送B接收的情况作为例子；</li> <li>发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；</li> <li>发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；</li> <li>每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送；</li></ol> <h4 id="过程举例"><a href="#过程举例" class="header-anchor">#</a> 过程举例</h4> <p><img src="https://images.zaiolos.top/images/202203121207953.png" alt="image-20220312120738847"></p> <p><img src="https://images.zaiolos.top/images/202203121210102.png" alt="image-20220312121038007"></p> <h4 id="为什么接收窗口大小为0-还能接收零窗口探测报文段"><a href="#为什么接收窗口大小为0-还能接收零窗口探测报文段" class="header-anchor">#</a> 为什么接收窗口大小为0，还能接收零窗口探测报文段？</h4> <p><code>TCP规定，即使接收窗口大小为0，也必须接收零窗口探测报文段、确认报文段、携带有紧急数据的报文段</code></p> <p><code>零窗口探测报文也有重传计时器，重传计时器超时，零窗口探测报文会重传，所以不用担心零窗口探测报文的丢失</code></p> <p>TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为‘20’：
字节31-50为发送窗口</p> <p><img src="https://images.zaiolos.top/images/202203052030185.png" alt="img"></p> <p>A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组：</p> <p><img src="https://images.zaiolos.top/images/202203052030145.png" alt="img"></p> <p>只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递：</p> <p><img src="https://images.zaiolos.top/images/202203052030051.png" alt="img"></p> <p>如果出现丢包现象：（如图中的7、8、9丢失）</p> <p><img src="https://images.zaiolos.top/images/202203052031396.png" alt="img"></p> <p><code>B给A发确认号为7，确认数据包中有“选择性确认段”，此时A只发送丢失的7-9，而不会再发10-12。</code></p> <h3 id="_6-2-传递效率"><a href="#_6-2-传递效率" class="header-anchor">#</a> 6.2 传递效率</h3> <blockquote><p>一个显而易见的问题是：单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，无疑增加了网络中的许多不必要的报文（请想想为了一个字节数据而添加的40字节头部吧！），所以我们的原则是尽可能一次多发送几个字节，或者窗口空余较多的时候通知发送方一次发送多个字节。对于前者我们广泛使用Nagle算法，即：</p> <ol><li>若发送应用进程要把发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来；</li> <li>当发送方收到第一个字节的确认后（也得到了网络情况和对方的接收窗口大小），再把缓冲区的剩余字节组成合适大小的报文发送出去；</li> <li>当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；对于后者我们往往的做法是让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。</li></ol></blockquote> <h2 id="_7-拥塞控制"><a href="#_7-拥塞控制" class="header-anchor">#</a> 7.拥塞控制</h2> <h3 id="_7-1-什么是拥塞-什么是拥塞控制"><a href="#_7-1-什么是拥塞-什么是拥塞控制" class="header-anchor">#</a> 7.1 什么是拥塞？什么是拥塞控制？</h3> <blockquote><p>在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就称为<strong>拥塞</strong>。简单的说<strong>拥塞产生的原因有两点：</strong>（1）接收方容量不够（2）网络内部有瓶颈</p></blockquote> <blockquote><p><strong>拥塞控制</strong>就是防止过多的数据注入到网络中，这样可以使网络中的<code>路由器或链路</code>不致过载。</p></blockquote> <h3 id="_7-2-检测网络拥塞的方法"><a href="#_7-2-检测网络拥塞的方法" class="header-anchor">#</a> 7.2 检测网络拥塞的方法？</h3> <blockquote><ol><li><p>发送数据后规定时间没有收到回应可以判定堵塞</p></li> <li><p>发送数据后收到同一条报文的四次确认，可认为丢失-------------这种情况就是根据TCP传输数据的特点：发送12345个数据段，接受端收到1的时候会返回2的确认报文也就是说我收到了2之前的下一次我就想要2了--------收到2之后返回3的确认报文------但是现在3迟迟未到-------4到了储存下来还是返回3的确认---5到了还是如此----然后3才到又发现缓存里面有45就返回6的确认报文表示之前的我都收到了，</p> <p>若发送方接收到对同一条报文的三次冗余确认（也就是四次确认），就认为这条报文的下一条已经丢失，于是不管计时器是否超时，都直接重传这条报文的下一条。快速重传的条件发生，发送方将认为出现了拥塞导致丢包。</p> <p>所以TCP判断拥塞就是判断有没有丢包</p></li></ol></blockquote> <h3 id="_7-3-网络拥塞的表现"><a href="#_7-3-网络拥塞的表现" class="header-anchor">#</a> 7.3 网络拥塞的表现？</h3> <blockquote><p>主机ab通话，由主机a发送数据给主机b的时候不是直达，而是通过网络中的路由器等等，-----</p> <p>路由器先储存这些数据，然后再从中取出，根据数据中的地址转发给下一个离主机b近的路由器或者直接到达主机b-----</p> <p>有一个问题就是路由器的内存是有限的，如果同一时间到达的数据太多路由器接受不了就只能丢弃一部分，或者路由器数据本来就多后来的数据就要等很长时间才能转发</p> <p><strong>所以网络中数据太多，路由器处理不过来或者太慢就是网络拥塞</strong></p></blockquote> <h3 id="_7-4-tcp-ip协议的拥塞控制"><a href="#_7-4-tcp-ip协议的拥塞控制" class="header-anchor">#</a> 7.4 TCP/IP协议的拥塞控制？</h3> <p><code>TCP</code>进行拥塞控制的四种算法：慢开始、拥塞避免、快速重传、快速恢复。</p> <ul><li><strong>MSS</strong>：最大报文段长度，<code>TCP</code>双方发送的报文段中，包含的数据部分的最大字节数；</li> <li><strong>cwnd</strong>：拥塞窗口，<code>TCP</code>发送但还没有得到确认的报文的序号 都在这个区间；</li> <li><strong>RTT</strong>：往返时间，发送方发送一个报文，到接收这个报文的确认报文所经历的时间；</li> <li><strong>ssthresh</strong>：慢开始门限值，慢开始阶段，若<code>cwnd</code>的大小达到这个值，将转换到拥塞避免模式；</li></ul> <p><img src="https://images.zaiolos.top/images/202203121348232.png" alt="image-20220312133903694"></p> <p><strong>三种模式要相互转换</strong></p> <p>例如初始cwnd=1 ssthresh=16</p> <ol><li><p>慢开始</p> <blockquote><p><code>慢开始</code>算法思想：当主机开始发送数据时，由于并不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞，所以由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值，试探一下网络的拥塞情况。慢开始规定，在发送方每收到一个新的报文段的确认后，拥塞窗口的值就增大1，刚开始我们先设置拥塞窗口值为1，发送方收到一个新的确认报文之后，cwnd变为2，发送方接收到两个新的确认报文之后cwnd加2变成4。即拥塞窗口的增长每次都是收到确认报文段数量的2倍。为了防止拥塞窗口增长多大引起网络阻塞，为其设置了一个慢启动门限，当到达门限时，就进入到拥塞避免阶段</p></blockquote> <p>每传一次数据cwnd指数增长：2、4、8、16</p> <p>当cwnd=ssthresh=16的时候就变成拥塞避免</p></li> <li><p>拥塞避免</p> <blockquote><p><code>拥塞避免</code>算法的思路：不再以指数形式增长拥塞窗口，而是每经过一个往返时间RTT就将发送方的拥塞窗口+1，使其增长缓慢，按照线性方式增长，如果发生网络拥塞，比如丢包时，就将慢启动门限设为原来的一半，然后将拥塞窗口设置为1，开始执行慢启动算法。</p></blockquote> <p>这个时候每传一次数据cwnd+1，线性增长，当cwnd=24的时候如果一直没有接收到回应那可以认为发送拥塞了就会超时重传，这个时候</p> <p>将慢开始门限值变为发生拥塞时cwnd的一半：ssthresh=cwnd/2=12，然后让cwnd减小为1重新开始慢启动算法，然后当cwnd=ssthresh=12的时候又开始拥塞避免</p> <p>然后假如当cwnd=16的时候，接受到了同一个报文三次重复确认，但是也许并没有发生拥塞所以就启动快重传</p> <p><img src="https://images.zaiolos.top/images/202203121348697.png" alt="image-20220312134803602"></p></li> <li><p>快重传：</p> <blockquote><p><code>快速重传</code>算法思想：快速重传要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。快速重传规定，发送方只要一连接收到3个重复确认，就知道接收方确实没有收到该报文段，因而应当立即进行重传，这样就不会出现超时，发送方也就不会误认为出现了网络拥塞。使用快速重传可以使整个网络的吞吐量提高约20%。快速重传后进入快速恢复。</p></blockquote></li></ol> <p><img src="https://images.zaiolos.top/images/202203121352059.png" alt="image-20220312135159944"></p> <p>快速重传的图解：</p> <p><img src="https://images.zaiolos.top/images/202203121356648.png" alt="image-20220312135609540"></p> <ol start="4"><li><p>快速恢复</p> <blockquote><p><code>快速恢复</code>的思想：</p> <ul><li>发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；不再执行慢启动而是直接进入拥塞避免阶段，使发送窗口成线性方式增长</li> <li>也有的快速恢复实现是把快速恢复时的拥塞窗口cwnd值再增大一些（即3个报文段长度），即等于新的ssthresh+3个报文段长度。这样做的理由是，既然发送方收到3个重复的确认，就表明有3个报文段已经离开了网络。这3个报文段不再消耗网络的资源，而是停留在接收方的缓冲区种（接收方发送出了3个重复确认就证明了这个事实）。可见现在网络中并不是堆积了报文段，而是减少了3个报文段。因此可以适当的把拥塞窗口扩大些</li></ul></blockquote></li></ol> <h2 id="_8-arp是地址解析协议-简单解释下工作原理"><a href="#_8-arp是地址解析协议-简单解释下工作原理" class="header-anchor">#</a> 8.ARP是地址解析协议，简单解释下工作原理</h2> <ol><li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li> <li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。</li> <li>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li> <li>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ol> <h2 id="_9-icmp协议"><a href="#_9-icmp协议" class="header-anchor">#</a> 9.ICMP协议</h2> <blockquote><p>ICMP是Internet Control Message Protocol，因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由器是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文。</p></blockquote> <h2 id="_10-dhcp协议"><a href="#_10-dhcp协议" class="header-anchor">#</a> 10.DHCP协议</h2> <p><img src="https://images.zaiolos.top/images/202203140947156.png" alt="image-20220314094733031"></p> <p><img src="https://images.zaiolos.top/images/202203140957989.png" alt="image-20220314095723865"></p> <blockquote><p>动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。</p></blockquote> <h2 id="_11-ttl是什么-作用是什么-哪些工具会用到它"><a href="#_11-ttl是什么-作用是什么-哪些工具会用到它" class="header-anchor">#</a> 11.TTL是什么？作用是什么？哪些工具会用到它?</h2> <blockquote><p>TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，则将数据包丢弃。</p> <p>使用TTL：</p> <ul><li>ping发送数据包里面有TTL，但是并非是必须的，即是没有TTL也是能正常工作的</li> <li>traceroute正是因为有了TTL才能正常工作</li> <li>ifconfig是用来配置网卡信息的，不需要TTL</li> <li>netstat是用来显示路由表的，也是不需要TTL的</li></ul></blockquote> <h2 id="_12-web页面的请求过程"><a href="#_12-web页面的请求过程" class="header-anchor">#</a> 12.web页面的请求过程</h2> <ul><li><a href="##web-%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E5%8E%86%E7%A8%8B">Web 页面的请求历程</a> <ul><li><a href="###%E6%9F%A5%E6%89%BE-dns-%E7%BC%93%E5%AD%98">查找 DNS 缓存</a></li> <li><a href="#%E5%8F%91%E8%B5%B7-dns-%E6%9F%A5%E8%AF%A2">发起 DNS 查询</a></li> <li><a href="#arp-%E8%AF%B7%E6%B1%82">ARP 请求</a></li> <li><a href="#%E5%B0%81%E8%A3%85-tcp-%E6%95%B0%E6%8D%AE%E5%8C%85">封装 TCP 数据包</a></li> <li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5">浏览器与目标服务器建立 TCP 连接</a></li> <li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82%E5%88%B0-web-%E6%9C%8D%E5%8A%A1%E5%99%A8">浏览器发送 HTTP 请求到 web 服务器</a></li> <li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%8F%91%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%93%8D%E5%BA%94">服务器处理请求并发回一个响应</a></li> <li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E5%9B%9E%E4%B8%80%E4%B8%AA-http-%E5%93%8D%E5%BA%94">服务器发送回一个 HTTP 响应</a></li> <li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA-html-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">浏览器显示 HTML 的相关内容</a></li></ul></li></ul> <p><img src="https://z3.ax1x.com/2021/03/30/cPRJrF.png" alt=""></p> <p>Hey guys 各位读者姥爷们大家好，这里是程序员 cxuan 计算机网络连载系列的第 13 篇文章。</p> <p>到现在为止，我们算是把应用层、运输层、网络层和数据链路层都介绍完了，那么现在是时候把这些内容都串起来，做一个全面的回顾了。那么我这就以 Web 页面的请求历程为例，来和你聊聊计算机网络中这些协议是怎样工作的、数据包是怎么收发的，从输入 URL 、敲击会车到最终完成页面呈现在你面前的这个过程。</p> <p>首先，我打开了 Web Browser ，然后在 Google 浏览器 URL 地址栏中输入了 <code>maps.google.com</code>。</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPcwPP.png" alt=""></p> <p>然后 ......</p> <h3 id="_12-1-查找-dns-缓存"><a href="#_12-1-查找-dns-缓存" class="header-anchor">#</a> 12.1 查找 DNS 缓存</h3> <p>浏览器在这个阶段会检查四个地方是否存在缓存，第一个地方是浏览器缓存，这个缓存就是 DNS 记录。</p> <p>浏览器会为你访问过的网站在固定期限内维护 DNS 记录。因此，它是第一个运行 DNS 查询的地方。 浏览器首先会检查这个网址在浏览器中是否有一条对应的 DNS 记录，用来找到目标网址的 IP 地址。</p> <p>我是 chrome 浏览器，所以在 mac 中，无法使用 <strong>chrome://net-internals/#dns</strong> 找到对应的 IP 地址，在 windows 中是可以找到的。</p> <blockquote><p>那么 mac 怎么查询 DNS 记录呢？你可以使用 <code>nslookup</code> 命令来查找，但这不是我们讨论的重点。</p></blockquote> <p><code>DNS(Domain Name System)</code> 是一个分布式的数据库，它用于维护网址 URL 到其 IP 地址的映射关系。在互联网中，IP 地址是计算机所能够理解的一种地址，而 DNS 的这种别名地址是我们人类能够理解和记忆的地址，DNS 就负责把人类记忆的地址映射成计算机能够理解的地址，每个 URL 都有唯一的 IP 地址进行对应。</p> <p>举个例子，google 的官网是 www.google.com ，而 google 的 ip 地址是 216.58.200.228 ，这两个地址你在 URL 上输入哪个都能访问，但是 IP 地址不好记忆，而 google.com 简单明了。DNS 就相当于是我们几年前使用的家庭电话薄，比如你想给 cxuan 打电话，你有可能记不住 cxuan 的电话号码，此时你需要查询电话薄来找到 cxuan 的电话号码。</p> <p>浏览器第二个需要检查的地方就是<strong>操作系统缓存</strong>。如果 DNS 记录不在浏览器缓存中，那么浏览器将对操作系统发起系统调用，Windows 下就是 <code>getHostName</code>。</p> <blockquote><p>在 Linux 和大部分 UNIX 系统上，除非安装了 <code>nscd</code>，否则操作系统可能没有 DNS 缓存。</p> <p>nscd 是 Linux 系统上的一种<strong>名称服务缓存程序</strong>。</p></blockquote> <p>浏览低第三个需要检查的地方是<strong>路由器缓存</strong>，如果 DNS 记录不在自己电脑上的话，浏览器就会和与之相连的路由器共同维护 DNS 记录。</p> <p>如果与之相连的路由器也没有 DNS 记录的话，浏览器就会检查 <code>ISP</code> 中是否有缓存。ISP 缓存就是你本地通信服务商的缓存，因为 ISP 维护着自己的 DNS 服务器，它缓存 DNS 记录的本质也是为了降低请求时间，达到快速响应的效果。一旦你访问过某些网站，你的 ISP 可能就会缓存这些页面，以便下次快速访问。对于经常看小电影的你是否感到震惊呢？如果家里还安装了一个可以联网的摄像头的话，那就有点嗨皮了。</p> <blockquote><p>你肯定比较困惑为什么第一步浏览器需要检查这么多缓存，你可能会感到不舒服，因为缓存可能会透露我们的隐私，但是这些缓存在调节网络流量和缩短数据传输时间等方面至关重要。</p></blockquote> <p>所以，上面涉及到 DNS 缓存的查询过程如下。</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPc08f.png" alt=""></p> <p>如果上面四个步骤中都不存在 DNS 记录，那么就表示不存在 DNS 缓存，这个时候就需要发起 DNS 查询，以查找目标网址（本示例中是 maps.google.com）的 IP 地址。</p> <h3 id="_12-2-发起-dns-查询"><a href="#_12-2-发起-dns-查询" class="header-anchor">#</a> 12.2 发起 DNS 查询</h3> <p>如上所述，如果想要使我的计算机和 maps.google.com 建立连接并进行通信的话，我需要知道 maps.google.com 的 IP 地址，由于 DNS 的设计原因，本地 DNS 可能无法给我提供正确的 IP 地址，那么它就需要在互联网上搜索多个 DNS 服务器，来找到网站的正确 IP 地址。</p> <blockquote><p>这里有个疑问，为什么我需要搜索多个 DNS 服务器的来找到网站的 IP 地址呢？一台服务器不行吗？</p></blockquote> <p>因为 DNS 是分布式域名服务器，每台服务器只维护一部分 IP 地址到网络地址的映射，没有任何一台服务器能够维持全部的映射关系。</p> <p>在 DNS 的早期设计中只有一台 DNS 服务器。这台服务器会包含所有的 DNS 映射。这是一种<code>集中式</code>的设计，这种设计并不适用于当今的互联网，因为互联网有着<strong>数量巨大并且持续增长</strong>的主机，这种集中式的设计会存在以下几个问题</p> <ul><li><code>单点故障(a single point of failure)</code>，如果 DNS 服务器崩溃，那么整个网络随之瘫痪。</li> <li><code>通信容量(traaffic volume)</code>，单个 DNS 服务器不得不处理所有的 DNS 查询，这种查询级别可能是上百万上千万级，一台服务器很难满足。</li> <li><code>远距离集中式数据库(distant centralized database)</code>，单个 DNS 服务器不可能 <code>邻近</code> 所有的用户，假设在美国的 DNS 服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低速和拥堵的链路，造成严重的时延。</li> <li><code>维护(maintenance)</code>，维护成本巨大，而且还需要频繁更新。</li></ul> <p>所以在当今网络情况下 DNS 不可能集中式设计，因为它完全没有可扩展能力，所以采用<code>分布式设计</code>，这种设计的特点如下</p> <p><strong>分布式、层次数据库</strong>。</p> <p>首先分布式设计首先解决的问题就是 DNS 服务器的扩展性问题，因此 DNS 使用了大量的 DNS 服务器，它们的组织模式一般是层次方式，并且分布在全世界范围内。<strong>没有一台 DNS 服务器能够拥有因特网上所有主机的映射</strong>。相反，这些映射分布在所有的 DNS 服务器上。</p> <p>大致来说有三种 DNS 服务器：<code>根 DNS 服务器</code>、 <code>顶级域(Top-Level Domain, TLD) DNS 服务器</code> 和 <code>权威 DNS 服务器</code> 。这些服务器的层次模型如下图所示</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPca5t.png" alt=""></p> <p><img src="https://z3.ax1x.com/2021/03/30/cPcUUI.png" alt=""></p> <ul><li><code>根 DNS 服务器</code> ，有 400 多个根域名服务器遍及全世界，这些根域名服务器由 13 个不同的组织管理。根域名服务器的清单和组织机构可以在 https://root-servers.org/ 中找到，根域名服务器提供 TLD 服务器的 IP 地址。</li> <li><code>顶级域 DNS 服务器</code>，对于每个顶级域名比如 com、org、net、edu 和 gov 和所有的国家级域名 uk、fr、ca 和 jp 都有 TLD 服务器或服务器集群。所有的顶级域列表参见 https://tld-list.com/ 。TDL 服务器提供了权威 DNS 服务器的 IP 地址。</li> <li><code>权威 DNS 服务器</code>，在因特网上具有公共可访问的主机，如 Web 服务器和邮件服务器，这些主机的组织机构必须提供可供访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构的权威 DNS 服务器收藏了这些 DNS 记录。</li></ul> <p>在了解了 DNS 服务器的设计理念之后，我们回到 DNS 查找的步骤上来，DNS 的查询方式主要分为三种</p> <p>DNS 查找中会出现三种类型的查询。通过组合使用这些查询，<strong>优化的 DNS 解析过程可缩短传输距离</strong>。在理想情况下，可以使用缓存的记录数据，从而使 DNS 域名服务器能够直接使用非递归查询。</p> <ul><li><code>递归查询</code>：在递归查询中，DNS 客户端要求 DNS 服务器（一般为 DNS 递归解析器）将使用所请求的资源记录响应客户端，或者如果解析器无法找到该记录，则返回错误消息。</li></ul> <p><img src="https://images.zaiolos.top/images/202203062015844.png" alt=""></p> <ul><li><code>迭代查询</code>：在迭代查询中，如果所查询的 DNS 服务器与查询名称不匹配，则其将返回对较低级别域名空间具有权威性的 DNS 服务器的引用。然后，DNS 客户端将对引用地址进行查询。此过程继续使用查询链中的其他 DNS 服务器，直至发生错误或超时为止。</li></ul> <p><img src="https://z3.ax1x.com/2021/03/30/cPcYbd.png" alt=""></p> <ul><li><code>非递归查询</code>：当 DNS 解析器客户端查询 DNS 服务器以获取其有权访问的记录时通常会进行此查询，因为其对该记录具有权威性，或者该记录存在于其缓存内。DNS 服务器通常会缓存 DNS 记录，查询到来后能够直接返回缓存结果，以防止更多带宽消耗和上游服务器上的负载。</li></ul> <p>上面负责开始 DNS 查找的介质就是 <strong>DNS 解析器</strong>，它一般是 ISP 维护的 DNS 服务器，它的主要职责就是通过向网络中其他 DNS 服务器询问正确的 IP 地址。</p> <p>如果想要了解更多关于 DNS 的消息，请查阅 <a href="https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;mid=2247487880&amp;idx=1&amp;sn=fd38ce30ae82fa7d08e5f83fabb9d497&amp;chksm=e999e49adeee6d8c1adacbfe27dc59097e4cb9d39c6a04802b0fe61877653330e75721cbde0b&amp;token=1399988516&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">万字长文爆肝 DNS 协议！<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>所以对于 maps.google.com 这个域名来说，如果 ISP 维护的服务器没有 DNS 缓存记录，它就会向 DNS 根服务器地址发起查询，根名称服务器会将其重定向到 .com 顶级域名服务器。 .com 顶级域名服务器会将其重定向到google.com 权威服务器。google.com 名称服务器将在其 DNS 记录中找到 maps.google.com 匹配的 IP 地址，并将其返回给您的 DNS 解析器，然后将其发送回你的浏览器。</p> <p>这里值得注意的是，DNS 查询报文会经过许多路由器和设备才会达到根域名等服务器，每经过一个设备或者路由器都会使用<code>路由表</code> 来确定哪种路径是数据包达到目的地最快的选择。这里面涉及到路由选择算法，如果小伙伴们想要了解路由选择算法，可以看看这篇文章 https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/13753-25.html#anc3</p> <h3 id="_12-3-arp-请求"><a href="#_12-3-arp-请求" class="header-anchor">#</a> 12.3 ARP 请求</h3> <p>我看了很多篇文章都没有提到这一点，那就是 ARP 请求的这个过程。</p> <blockquote><p>什么时候需要发送 ARP 请求呢？</p></blockquote> <p>这里其实有个前提条件</p> <ul><li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP 查询</li> <li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li></ul> <p>ARP 协议的全称是 <code>Address Resolution Protocol(地址解析协议)</code>，它是一个通过<strong>用于实现从 IP 地址到 MAC 地址的映射，即询问目标 IP 对应的 MAC 地址</strong> 的一种协议。</p> <p>简而言之，ARP 就是一种解决地址问题的协议，它以 IP 地址为线索，定位下一个应该接收数据分包的主机 MAC 地址。如果目标主机不在同一个链路上，那么会查找下一跳路由器的 MAC 地址。</p> <blockquote><p>关于为什么有了 IP 地址，还要有 MAC 地址概述可以参看知乎这个回答 https://www.zhihu.com/question/21546408</p></blockquote> <p>ARP 的大致工作流程如下</p> <p>假设 A 和 B 位于同一链路，不需要经过路由器的转换，主机 A 向主机 B 发送一个 IP 分组，主机 A 的地址是 192.168.1.2 ，主机 B 的地址是 192.168.1.3，它们都不知道对方的 MAC 地址是啥，主机 C 和 主机 D 是同一链路的其他主机。</p> <p><img src="https://images.zaiolos.top/images/202203062015029.png" alt=""></p> <p>主机 A 想要获取主机 B 的 MAC 地址，通过主机 A 会通过<code>广播</code> 的方式向以太网上的所有主机发送一个 <code>ARP 请求包</code>，这个 ARP 请求包中包含了主机 A 想要知道的主机 B 的 IP 地址的 MAC 地址。</p> <p><img src="https://images.zaiolos.top/images/202203062015158.png" alt=""></p> <p>主机 A 发送的 ARP 请求包会被同一链路上的所有主机/路由器接收并进行解析。每个主机/路由器都会检查 ARP 请求包中的信息，如果 ARP 请求包中的<code>目标 IP 地址</code> 和自己的相同，就会将自己主机的 MAC 地址写入响应包返回主机 A</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPcJDH.png" alt=""></p> <p>由此，可以通过 ARP 从 IP 地址获取 MAC 地址，实现同一链路内的通信。</p> <p>所以，要想发送 ARP 广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p> <p>这里会涉及到 <strong>ARP 缓存</strong>的概念。</p> <p>现在你知道了发送一次 IP 分组前通过发送一次 ARP 请求就能够确定 MAC 地址。那么是不是每发送一次都得经过广播 -&gt; 封装 ARP 响应 -&gt; 返回给主机这一系列流程呢？</p> <p>想想看，浏览器是如何做的？浏览器内置了缓存能够缓存你最近经常使用的地址，那么 ARP 也是一样的。ARP 高效运行的关键就是维护每个主机和路由器上的 <code>ARP 缓存(或表)</code>。这个缓存维护着每个 IP 到 MAC 地址的映射关系。通过把第一次 ARP 获取到的 MAC 地址作为 IP 对 MAC 的映射关系到一个 ARP 缓存表中，下一次再向这个地址发送数据报时就不再需要重新发送 ARP 请求了，而是直接使用这个缓存表中的 MAC 地址进行数据报的发送。每发送一次 ARP 请求，缓存表中对应的映射关系都会被清除。</p> <p>通过 ARP 缓存，降低了网络流量的使用，在一定程度上防止了 ARP 的大量广播。</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPc1gO.png" alt=""></p> <p>一般来说，发送过一次 ARP 请求后，再次发送相同请求的几率比较大，因此使用 ARP 缓存能够减少 ARP 包的发送，除此之外，不仅仅 ARP 请求的发送方能够缓存 ARP 接收方的 MAC 地址，接收方也能够缓存 ARP 请求方的 IP 和 MAC 地址，如下所示</p> <p><img src="https://z3.ax1x.com/2021/03/30/cPcl8K.png" alt=""></p> <p>不过，<strong>MAC 地址的缓存有一定期限，超过这个期限后，缓存的内容会被清除</strong>。</p> <p>深入理解 ARP 协议的话，可以参考 cxuan 的这篇文章。</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;mid=2247487804&amp;idx=1&amp;sn=f001a24a308053b3723dfb12d36045ee&amp;chksm=e999e42edeee6d383fbb411792e22e4028bb8c2441255786f50cf848443af7b1bd5e382078dc&amp;token=1623097963&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">ARP，这个隐匿在计网背后的男人<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <p>所以，浏览器会首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC。</p> <p>如果缓存没有命中：</p> <ul><li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</li> <li>查询选择的网络接口的 MAC 地址</li> <li>我们发送一个数据链路层的 ARP 请求：</li></ul> <p><img src="https://z3.ax1x.com/2021/03/30/cPcK4x.png" alt=""></p> <p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p> <p>直连：</p> <ul><li>如果我们和路由器是直接连接的，路由器会返回一个 <code>ARP Reply</code> （见下面）。</li></ul> <p>集线器：</p> <ul><li>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也连接在其中，它会返回一个 <code>ARP Reply</code> 。</li></ul> <p>交换机：</p> <ul><li>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</li> <li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li> <li>如果路由器也<code>连接</code>在其中，它会返回一个 <code>ARP Reply</code></li></ul> <p><code>ARP Reply</code>:</p> <p><img src="https://images.zaiolos.top/images/202203062015460.png" alt=""></p> <p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p> <ul><li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li> <li>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回。</li></ul> <p>（上述均来自：https://github.com/skyline75489/what-happens-when-zh_CN#dns）</p> <hr> <h3 id="_12-4-封装-tcp-数据包"><a href="#_12-4-封装-tcp-数据包" class="header-anchor">#</a> 12.4 封装 TCP 数据包</h3> <p>浏览器得到目标服务器的 IP 地址后，根据 URL 中的端口可以知道端口号 （http 协议默认端口号是 80， https 默认端口号是 443），会准备 TCP 数据包。数据包的封装会经过下面的层层处理，数据到达目标主机后，目标主机会解析数据包，完整的请求和解析过程如下。</p> <p><img src="https://images.zaiolos.top/images/202203062015367.png" alt=""></p> <p>这里就不再详细介绍了，读者朋友们可以阅读 cxuan 的这篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;mid=2247486408&amp;idx=1&amp;sn=c332ae7ae448f3eb98865003ecade589&amp;chksm=e999fedadeee77cc6281d1b170bd906b58220d6cd83054bc741821f4167f1f18ceee9ba0e449&amp;token=1623097963&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">TCP/IP 基础知识详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>详细了解。</p> <h3 id="_12-5-浏览器与目标服务器建立-tcp-连接"><a href="#_12-5-浏览器与目标服务器建立-tcp-连接" class="header-anchor">#</a> 12.5 浏览器与目标服务器建立 TCP 连接</h3> <p>在经过上述 DNS 和 ARP 查找流程后，浏览器就会收到一个目标服务器的 IP 和 MAC地址，然后浏览器将会和目标服务器建立连接来传输信息。这里可以使用很多种 Internet 协议，但是 HTTP 协议建立连接所使用的运输层协议是 TCP 协议。所以这一步骤是浏览器与目标服务器建立 TCP 连接的过程。</p> <p>TCP 的连接建立需要经过 TCP/IP 的三次握手，三次握手的过程其实就是浏览器和服务器交换 SYN 同步和 ACK 确认消息的过程。</p> <p>假设图中左端是客户端主机，右端是服务端主机，一开始，两端都处于<code>CLOSED（关闭）</code>状态。</p> <p><img src="https://images.zaiolos.top/images/202203062015575.png" alt=""></p> <ol><li>服务端进程准备好接收来自外部的 TCP 连接。然后服务端进程处于 <code>LISTEN</code> 状态，等待客户端连接请求。</li> <li>客户端向服务器发出连接请求，请求中首部同步位 SYN = 1，同时选择一个初始序号 sequence ，简写 seq = x。SYN 报文段不允许携带数据，只消耗一个序号。此时，客户端进入 <code>SYN-SEND</code> 状态。</li> <li>服务器收到客户端连接后，，需要确认客户端的报文段。在确认报文段中，把 SYN 和 ACK 位都置为 1 。确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。此时，TCP 服务器进入 <code>SYN-RECEIVED(同步收到)</code> 状态。</li> <li>客户端在收到服务器发出的响应后，还需要给出确认连接。确认连接中的 ACK 置为 1 ，序号为 seq = x + 1，确认号为 ack = y + 1。TCP 规定，这个报文段可以携带数据也可以不携带数据，如果不携带数据，那么下一个数据报文段的序号仍是 seq = x + 1。这时，客户端进入 <code>ESTABLISHED (已连接)</code> 状态</li> <li>服务器收到客户的确认后，也进入 <code>ESTABLISHED</code> 状态。</li></ol> <p>这样三次握手建立连接的阶段就完成了，双方可以直接通信了。</p> <h3 id="_12-6-浏览器发送-http-请求到-web-服务器"><a href="#_12-6-浏览器发送-http-请求到-web-服务器" class="header-anchor">#</a> 12.6 浏览器发送 HTTP 请求到 web 服务器</h3> <p>一旦 TCP 连接建立完成后，就开始直接传输数据办正事了！此时浏览器会发送 <code>GET</code> 请求，要求目标服务器提供 maps.google.com 的网页，如果你填写的是表单，则发起的是 <code>POST</code> 请求，在 HTTP 中，GET 请求和 POST 请求是最常见的两种请求，基本上占据了所有 HTTP 请求的九成以上。</p> <p>除了请求类型外，HTTP 请求还包含很多很多信息，最常见的有 Host、Connection 、User-agent、Accept-language 等</p> <p><img src="https://images.zaiolos.top/images/202203062015796.png" alt=""></p> <p>首先 Host 表示的是对象所在的主机。<code>Connection: close</code> 表示的是浏览器需要告诉服务器使用的是<code>非持久连接</code>。它要求服务器在发送完响应的对象后就关闭连接。<code>User-agent</code>: 这是请求头用来告诉 Web 服务器，浏览器使用的类型是 <code>Mozilla/5.0</code>，即 Firefox 浏览器。<code>Accept-language</code> 告诉 Web 服务器，浏览器想要得到对象的法语版本，前提是服务器需要支持法语类型，否则将会发送服务器的默认版本。下面我们针对主要的实体字段进行介绍（具体的可以参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers MDN 官网学习）</p> <p>HTTP 的请求标头分为四种： <code>通用标头</code>、<code>请求标头</code>、<code>响应标头</code> 和 <code>实体标头</code>。</p> <p>这四种标头又分别有很多内容，如果你想要深入理解一下关于 HTTP 请求头的相关内容，可以参考 cxuan 的这篇文章</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;mid=2247496023&amp;idx=1&amp;sn=7281feaf0853d5465d7b082329b7f2d7&amp;chksm=c04ae609f73d6f1f2bac28a3222f83ce24ef199e9869e887aa23f627f194d9d9cb43e1683ddb&amp;token=1307572136&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">深入理解 HTTP 标头<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_12-7-服务器处理请求并发回一个响应"><a href="#_12-7-服务器处理请求并发回一个响应" class="header-anchor">#</a> 12.7 服务器处理请求并发回一个响应</h3> <p>这个服务器包含一个 Web 服务器，也就是 Apache 服务器，服务器会从浏览器接收请求并将其传递给请求处理程序并生成响应。</p> <blockquote><p>请求处理程序也是一个程序，它一般是用 .net 、php、ruby 等语言编写，用于读取请求，检查请求内容，cookie，必要时更新服务器上的信息的这么一个程序。它会以特定的格式比如 JSON、XML、HTML 组合响应。</p></blockquote> <h3 id="_12-8-服务器发送回一个-http-响应"><a href="#_12-8-服务器发送回一个-http-响应" class="header-anchor">#</a> 12.8 服务器发送回一个 HTTP 响应</h3> <p>服务器响应包含你请求的网页以及状态代码，压缩类型（Content-Encoding），如何缓存页面（Cache-Control），要设置的 cookie，隐私信息等。</p> <p>比如下面就是一个响应体</p> <p><img src="https://images.zaiolos.top/images/202203062015075.png" alt=""></p> <p>关于深入理解 HTTP 请求和响应，可以参考这篇文章</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;mid=2247496030&amp;idx=1&amp;sn=82f56874f82f372af71e23a8e385f8cd&amp;chksm=c04ae600f73d6f16d707c1d32b00e3f0d47e893c9cf59a2eb60ace418943aeb5c5c679cb27ea&amp;token=1307572136&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">看完这篇HTTP，跟面试官扯皮就没问题了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_12-9-浏览器显示-html-的相关内容"><a href="#_12-9-浏览器显示-html-的相关内容" class="header-anchor">#</a> 12.9 浏览器显示 HTML 的相关内容</h3> <p>浏览器会分阶段显示 HTML 内容。 首先，它将渲染裸露的 HTML 骨架。 然后它将检查 HTML 标记并发送 GET 请求以获取网页上的其他元素，例如图像，CSS 样式表，JavaScript 文件等。这些静态文件由浏览器缓存，因此你再次访问该页面时，不用重新再请求一次。最后，您会看到 maps.google.com 显示的内容出现在你的浏览器中。</p> <h2 id="_13-dns-domain-name-system"><a href="#_13-dns-domain-name-system" class="header-anchor">#</a> 13.DNS(Domain Name System)</h2> <blockquote><p>当我们在浏览器的地址栏输入域名时，用户主机会首先在自己的DNS高速缓存中查找该域名所对应的IP地址，如果没有找到，则会向网络中的某台DNS服务器中有域名和IP地址映射关系的数据库，当DNS服务器收到DNS查询报文后，在其数据库中进行查询，之后将查询结果发送给用户主机，主机中的浏览器就可以通过web服务器的IP地址对其进行访问了</p></blockquote> <h3 id="_13-1概要"><a href="#_13-1概要" class="header-anchor">#</a> 13.1概要</h3> <ul><li><p>因特网采用<code>层次树状结构的域名结构</code></p></li> <li><p>域名的结构由若干个分量组成，各分量之间用&quot;点&quot;隔开，分别代表不同级别的域名</p> <p><img src="https://images.zaiolos.top/images/202203141011347.png" alt="image-20220314101111303"></p> <ul><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母</li> <li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边</li> <li>完整的域名不超过255个字符</li></ul></li> <li><p>域名系统既不规定一个域名需要包含多少个夏季域名，也不规定每一级的域名代表什么意思</p></li> <li><p>各级域名由其上一级的域名管理结构管理，而最高的顶级域名则由因特网名与数字地址分配机构ICANN进行管理。</p></li></ul> <h3 id="_13-2域名结构"><a href="#_13-2域名结构" class="header-anchor">#</a> 13.2域名结构：</h3> <p><img src="https://images.zaiolos.top/images/202203141016645.png" alt="image-20220314101646534"></p> <h3 id="_13-3域名空间"><a href="#_13-3域名空间" class="header-anchor">#</a> 13.3域名空间：</h3> <p><img src="https://images.zaiolos.top/images/202203141018070.png" alt="image-20220314101835963"></p> <h3 id="_13-4域名划分"><a href="#_13-4域名划分" class="header-anchor">#</a> 13.4域名划分</h3> <ul><li><p>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</p></li> <li><p>域名服务器可以划分为以下四种不同的类型：</p> <ul><li><p><strong>根域名服务器</strong></p> <blockquote><p>根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。<code>根域名服务器通常并不直接对城名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</code>。</p></blockquote></li> <li><p><strong>顶级域名服务器</strong></p> <blockquote><p>这些域名服务器负责<code>管理在该顶级域名服务器注册的所有二级域名</code>。当收到DNS查询请求时就给出相应的回答（(可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</p></blockquote></li> <li><p><strong>权限域名服务器</strong></p> <blockquote><p>这些域名服务器负责<code>管理某个区</code>的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址。</p></blockquote></li> <li><p><strong>本地域名服务器</strong></p> <blockquote><p>本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。<code>本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中</code>。每一个因特网服务提供者ISP，一个大学，甚至一个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为<code>默认域名服务器</code>。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。</p></blockquote></li></ul></li></ul> <h3 id="_13-5域名解析的过程"><a href="#_13-5域名解析的过程" class="header-anchor">#</a> 13.5域名解析的过程</h3> <ol><li><p>递归查询</p> <p><img src="https://images.zaiolos.top/images/202203141027220.png" alt="image-20220314102730156"></p></li> <li><p>迭代查询</p> <p><img src="https://images.zaiolos.top/images/202203141028194.png" alt="image-20220314102851109"></p></li></ol> <blockquote><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p></blockquote> <p><img src="https://images.zaiolos.top/images/202203141029667.png" alt="image-20220314102950580"></p> <blockquote><p>由于域名到IP地址的映射关系并不是永久不变，为保持告诉缓存中的内容正确，域名服务器<code>应为每项内容设置计时器并删除超过合理时间的项</code>(例如，每个项目只存放两天)</p></blockquote> <blockquote><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。</p></blockquote></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/hnistzdk/my-notes/edit/master/docs/06.面试刷题/01.面试/03.网络.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/my-notes/tags/?tag=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" title="标签">#计算机网络</a></div> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">2022/10/04, 8:10:00</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/my-notes/work/interview/os/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">操作系统</div></a> <a href="/my-notes/work/interview/framework/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">框架</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/my-notes/work/interview/os/" class="prev">操作系统</a></span> <span class="next"><a href="/my-notes/work/interview/framework/">框架</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:369365576@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/hnistzdk" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://gitee.com/hnistzdk" title="GitHub" target="_blank" class="iconfont icon-gitee"></a><a href="http://music.163.com/playlist?id=936642760&amp;userid=604011130" title="普通歌单" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2023
    <span>zdk | notes <br><a href=http://beian.miit.gov.cn/>湘ICP备2022001117号-1</a><br><img src=/img/ghs.png /><a href=http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51142102511562>川公网安备 51142102511562号</a><br><a href=https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referra><img src=/img/upyun.png align=absmiddle width=70px height=30px /></a> <span> 提供加速服务 </span></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><div id="goTop" class="hide-cat" data-v-bf92849a></div><div></div><div></div></div></div>
    <script src="/my-notes/assets/js/app.7f931ee0.js" defer></script><script src="/my-notes/assets/js/2.e52a17f8.js" defer></script><script src="/my-notes/assets/js/168.23aca72c.js" defer></script><script src="/my-notes/assets/js/6.bcc16901.js" defer></script>
  </body>
</html>
