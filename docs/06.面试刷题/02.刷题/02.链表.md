---
title: 链表
date: 2022-02-22 16:32:55
permalink: /work/algorithm/LinkedList
categories:
  - 面试刷题
  - 刷题
tags:
  - 链表
---

## 链表题



### (`easy`)反转链表

- 使用栈

  > 将结点依次入驻完然后出栈即可实现反转。
  >
  > 注意：要保存新的头结点的值，不能直接用头结点去拼接结点(使用dummy结点)

  ```java
  class Solution {
      public ListNode reverseList(ListNode head) {
          Deque<ListNode> stack = new LinkedList<>();
          while(head!=null){
              stack.push(head);
              head = head.next;
          }
          ListNode res = new ListNode();
          ListNode dummy = new ListNode(-1);
          res = dummy;
          while(!stack.isEmpty()){
              res.next = stack.pop();
              res = res.next;
          }
          res.next = null;
          return dummy.next;
      }
  }
  ```

- 迭代

  > 思路就是逆转相邻两结点的next指向即可

  ```java
  class Solution {
      public ListNode reverseList(ListNode head) {
          ListNode pre = null;
          ListNode cur = head;
          while(cur != null){
              ListNode next = cur.next;
              cur.next = pre;
              pre = cur;
              cur = next;
          }
          return pre;
      }
  }
  ```

- 使用递归

  > `reverseList` 函数定义是这样的：
  >
  > **输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的头结点**。

  ```java
  class Solution {
      public ListNode reverseList(ListNode head) {
          if (head == null || head.next == null){
              return head;
          }
          ListNode last = reverseList(head.next);
          head.next.next = head;
          head.next = null;
          return last;
      }
  }
  ```



### (`medium`)反转链表||

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。



思路：

> 交换前：
> - 使用哑结点，以便头结点的交换。
> - 找到左节点的前一个结点、左节点、右节点、右节点的后一个结点。 
> -  然后交换区间内的right-left+1个结点的位置，需要交换right-left次。
> -  交换前需要直接将当前第一个结点cur(即初始左节点)的next指向右节点的后一个结点;
> -  将cur的前一个结点的next指向右节点。
>
> 交换：
> - 将要交换的第二个结点标记。
> -  使用temp结点来储存这第二个结点的后一结点，便于第二结点后移
> -  然后让第二个结点next指向cur，cur移动到next，next移动到temp
>
> ![在这里插入图片描述](https://gitee.com/hnistzdk/picture/raw/master/images/202202281543321.png)



代码：

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        int index = 1;
        ListNode preNode = null;
        ListNode postNode = null;
        ListNode leftNode = null;
        ListNode rightNode = null;
        ListNode temp = dummy;
        for (int i = 0; i < left-1; i++) {
            temp = temp.next;
        }
        preNode = temp;
        leftNode = temp.next;
        for (int i = 0; i < right-left+1; i++) {
            temp = temp.next;
        }
        rightNode = temp;
        postNode = temp.next;

        //将要反转的这个区间里的链表截断
        preNode.next = null;
        rightNode.next = null;

        //将区间链表反转
        ListNode pre = null;
        ListNode cur = leftNode;
        while (cur!=null){
            //现结点的后一个结点
            ListNode next = cur.next;
            //现在的结点的next指向它的前一个结点
            cur.next = pre;
            //反转一次后 前结点后移
            pre = cur;
            //现结点也后移
            cur = next;
        }
        //将原left左边的结点接到要反转的最右结点上
        preNode.next = rightNode;
        //将要反转的最左结点,接到原右节点的位置
        leftNode.next = postNode;
        return dummy.next;
    }
}
```



