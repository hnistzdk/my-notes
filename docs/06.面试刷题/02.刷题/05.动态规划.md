---
title: 动态规划
date: 2022-03-04 16:55:01
permalink: /work/algorithm/dp
categories:
  - 面试刷题
  - 刷题
tags:
  - 动态规划
---

# 动态规划

## 概

**首先，动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求**最长**递增子序列呀，**最小**编辑距离呀等等。

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

首先，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**，才能正确地穷举。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，**写出状态转移方程是最困难的**，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

按上面的套路走，最后的结果就可以套这个框架：

```java
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```



### 1.(`medium`)零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。



示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0


提示：

1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104



思路：

> 官方题解：
>
> 我们采用自下而上的方式进行思考。仍定义F(i)为组成金额i所需最少的硬币数量，假设在计算F(i) 之前，我们已经计算出 F(0)-F(i-1)的答案。 则F(i)对应的转移方程应为
>
> ![image-20220312102627085](http://zdk-blog-image.test.upcdn.net//images/202203121026130.png)
>
> 其中 cj代表的是第j枚硬币的面值，即我们枚举最后一枚硬币面额是cj，那么需要从 i-cj这个金额的状态 F(i-cj)转移过来，再算上枚举的这枚硬币数量1的贡献，由于要硬币数量最少，所以F(i)为前面能转移过来的状态的最小值加上枚举的硬币数量1。

`理解：dp[i] = min(dp[i],dp[i-coin]+1)。这里相当于最后一枚硬币面额是coin，那么amount==i的情况下，所需数量dp[i]就等于去掉这最后一枚硬币coin的情况时需要的数量，加上硬币coin的1与它本身取最小值`



代码：

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;
        for(int i = 1;i <= amount;i++){
           for(int coin : coins){
               if(i-coin<0){
                   continue;
               }
               dp[i] = Math.min(dp[i-coin]+1,dp[i]);
           } 
        }
        return dp[amount] == (amount+1) ? -1 : dp[amount];
    }
}
```

