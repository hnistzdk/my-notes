---
title: 数组
date: 2022-03-01 09:19:30
permalink: /work/algorithm/array
categories:
  - 面试刷题
  - 刷题
tags:
  - 数组
---



## 数组相关题

### 1.(`easy`)移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

思路1：

> 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。
>
> 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
>
> 注意到以下性质：
>
> 左指针左边均为非零数；
>
> 右指针左边直到左指针处均为零。
>
> 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。
>



代码：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0;
        int right = 0;
        while (right < nums.length) {
            if (nums[right] != 0) {
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }

    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```





思路2：

> 使用双指针，左指针始终指向0的位置，右指针指向非0位置。
>
> - 如果当前左右指针都不为0，将两个指针都向后移一位
> - 如果左指针为0，右指针不为0，交换，将两个指针都向后移一位
> - 其他情况就只移动右指针即可



代码：

```java
public void moveZeroes(int[] nums) {
        int left = 0;
        int right = 0;
        while (right < nums.length) {
            if (nums[left] != 0 && nums[right] != 0) {
                left++;
            }
            else if(nums[left] == 0 && nums[right] != 0){
                swap(nums,left,right);
                left++;
            }
            right++;
        }
    }
```



### 2.(`medium`)和为K的子数组

给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

 

示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

输入：nums = [1,2,3], k = 3
输出：2



思路1：

> 很容易想到利用前缀和，得出每个[0,i]区间的子数组之和，然后[i,j]区间之和就等于[0,j]-[0,i]。
>
> 求出前缀和以后，枚举所有区间前缀和之差，等于k就res加一。
>
> 时间复杂度为O(n2)，空间复杂度O(1)
>
> 
>
> 我的比官方暴力要快几百ms

代码：

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        int[] preSum = new int[nums.length];
        preSum[0] = nums[0];
        for(int i = 1;i<nums.length;i++){
            preSum[i] = preSum[i-1]+nums[i];
        }
        for(int i = 0;i<preSum.length;i++){
            if(preSum[i] == k){
                res++;
            }
            for(int j = i+1;j<preSum.length;j++){
                if(preSum[j]-preSum[i] == k){
                    res++;
                }
            }
        }
        return res;
    }
}
```



思路2：

> 因为暴力的时间复杂度很高，我们可以利用hash表对算法进行优化。
>
> 暴力时我们使用的是 [0,j]-[0,i]==k 即是否存在两个前缀和之差等于k来寻找符合条件的[i,j]子数组。
>
> 
>
> 我们可以换个思路，使用一个HashMap<Integer,Integer>()，将前缀和以key存入HashMap，value为这种前缀和出现的次数，
>
> 比如k=7，数组为：0 7 2 5 3 -1，前缀和为：0 7 9 14 17 16，
>
> 我们要找前缀和之间差为7的，只需要去map里面找每个前缀和，有多少个与它之差为7的。
>
> 所以我们把每个前缀和以及它的数量存入map，找到key为 当前前缀和-k，的前缀和的数量让res加上即可在O(1)内获得结果
>
> 
>
> 这种思想的根本是，不是用区间(前缀和)去找差为K的区间数量，而是根据一个前缀和A，去找另一个满足A-B==K的前缀和B的数量

代码：

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        int pre = 0;
        HashMap<Integer,Integer> map = new HashMap<>();
        //先put一个0进去是为了nums[i]==k的情况，即只有一个元素的子数组
        map.put(0,1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            if(map.containsKey(pre-k)){
                res+=map.get(pre-k);
            }
            map.put(pre, map.getOrDefault(pre,0)+1);
        }
        return res;
    }
}
```

