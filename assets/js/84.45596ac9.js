(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{432:function(s,a,t){"use strict";t.r(a);var v=t(1),_=Object(v.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[a("strong",[s._v("Table of Contents")]),s._v(" "),a("em",[s._v("generated with "),a("a",{attrs:{href:"https://github.com/thlorenz/doctoc",target:"_blank",rel:"noopener noreferrer"}},[s._v("DocToc"),a("OutboundLink")],1)])]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#aof%E6%97%A5%E5%BF%97"}},[s._v("AOF日志")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#aof%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"}},[s._v("AOF相关配置")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E5%86%99%E5%89%8D%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97"}},[s._v("写前、写后日志")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97"}},[s._v("Redis为什么使用写后日志")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#aof%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E7%8E%B0"}},[s._v("AOF的持久化实现")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#aof%E7%9A%84%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"}},[s._v("AOF的写回策略")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E5%AF%B9%E6%AF%94"}},[s._v("对比")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"}},[s._v("如何选择")])])])]),s._v(" "),a("li",[a("a",{attrs:{href:"#aof%E7%9A%84%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"}},[s._v("AOF的重写机制")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E6%A6%82%E8%BF%B0"}},[s._v("概述")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B"}},[s._v("重写过程")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E9%87%8D%E5%86%99%E8%A7%A6%E5%8F%91%E7%9A%84%E6%97%B6%E6%9C%BA"}},[s._v("重写触发的时机")])])])])])]),s._v(" "),a("li",[a("a",{attrs:{href:"#rdb%E5%BF%AB%E7%85%A7"}},[s._v("RDB快照")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#rdb%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"}},[s._v("RDB相关配置")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#rdb%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"}},[s._v("RDB持久化流程")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E5%BF%AB%E7%85%A7%E7%9A%84%E9%A2%91%E7%8E%87"}},[s._v("快照的频率")])])])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E4%B8%A4%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"}},[s._v("两种持久化方式的对比")])]),s._v(" "),a("li",[a("a",{attrs:{href:"#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%9640"}},[s._v("混合持久化(4.0+)")])])]),s._v(" "),a("hr"),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("概述")]),s._v(" "),a("p",[s._v("在日常开发中，Redis一般都是用来作为"),a("strong",[s._v("缓存")]),s._v("存在的，也就是将关系数据库数据利用Redis储存在内存中，然后查询时先从缓存(内存)读取数据，响应速度就非常快了。并且缓存还可以降低数据库的访问压力，但是这里也有一个不可忽视的问题："),a("strong",[s._v("一旦服务宕机，内存中的数据就会全部丢失")]),s._v("。\n为了保证数据的持久化，"),a("strong",[s._v("Redis提供了两种持久化方案：AOF日志和RBD快照")]),s._v("，开发者可以根据实际业务情况，在项目中灵活配置")])]),s._v(" "),a("h2",{attrs:{id:"aof日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof日志"}},[s._v("#")]),s._v(" AOF日志")]),s._v(" "),a("blockquote",[a("p",[s._v("AOF是（Append Only File）的缩写，会记录Redis收到的每一条命令，并以文件形式保存")])]),s._v(" "),a("h3",{attrs:{id:"aof相关配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof相关配置"}},[s._v("#")]),s._v(" AOF相关配置")]),s._v(" "),a("blockquote",[a("p",[s._v("Redis默认不开启AOF持久化方式，需要修改redis.conf配置文件进行配置")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('# 开启aof机制\nappendonly yes\n\n# aof文件名\nappendfilename "appendonly.aof"\n\n# 写入策略 默认 everysec\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n\n# 自动重写配置\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# 保存目录\ndir ./\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("h3",{attrs:{id:"写前、写后日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写前、写后日志"}},[s._v("#")]),s._v(" 写前、写后日志")]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("AOF是写后日志，跟MySQL的写前日志(WAL)相反。\n"),a("ul",[a("li",[s._v("写前日志指的是：在实际写入数据前，先把修改的数据记录到日志文件，以便故障时进行恢复。")]),s._v(" "),a("li",[a("strong",[s._v("写后日志指的是：Redis先执行命令，把数据写入内存，然后再记录命令日志到磁盘文件")])])])])])]),s._v(" "),a("h3",{attrs:{id:"redis为什么使用写后日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis为什么使用写后日志"}},[s._v("#")]),s._v(" Redis为什么使用写后日志")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("why")]),s._v(" "),a("p",[s._v("Redis为了"),a("strong",[s._v("避免额外的性能开销")]),s._v("，再向AOF里面记录日志的时候，并不会先去检查命令的语法正确性，而是先让系统执行命令，只有执行成功之后，这条命令才会被记录下来，否则系统就会报错，所以"),a("strong",[s._v("写后日志的好处之一就是，防止出现错误命令的问题。")]),s._v("\n此外，另一个好处就是，因为是在命令执行之后，才去记录日志，所以"),a("strong",[s._v("不会阻塞当前的写操作")])])]),s._v(" "),a("p",[a("strong",[s._v("当然，写后日志也会带来一定风险")])]),s._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),a("ul",[a("li",[s._v("首先第一个："),a("strong",[s._v("数据丢失")]),s._v("。如果执行完一个命令，还没来得及写入日志，系统就宕机，此时就会发生数据丢失。")]),s._v(" "),a("li",[s._v("其次："),a("strong",[s._v("线程阻塞")]),s._v("。AOF日志是在主线程中执行的，如果在日志写入磁盘的时候，磁盘写的压力大，就会导致写盘很慢，而"),a("strong",[s._v("因为Redis是单线程的，如果主线程发生了阻塞，就会导致后续的操作都无法进行。")])])])]),s._v(" "),a("p",[s._v("这两个风险都和AOF写回磁盘的时机相关，如果能找到一种合适的时机，这两个风险应该就可以避免，下面会介绍如何避免这两个风险。")]),s._v(" "),a("h3",{attrs:{id:"aof的持久化实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof的持久化实现"}},[s._v("#")]),s._v(" AOF的持久化实现")]),s._v(" "),a("p",[s._v("AOF的持久化实现分为三个步骤：")]),s._v(" "),a("ol",[a("li",[s._v("命令追加：当AOF持久化功能被打开时，服务器执行完一个命令之后，会以协议格式将被执行的命令追加到"),a("code",[s._v("aof_buf")]),s._v(" 缓冲区的末尾；")]),s._v(" "),a("li",[s._v("文件写入：将"),a("code",[s._v("aof_buf")]),s._v(" 缓冲区的内容写入和保存到AOF文件，具体的写回策略由 "),a("code",[s._v("appendfsync")]),s._v(" 选项的值来确定；")]),s._v(" "),a("li",[s._v("文件同步")])]),s._v(" "),a("h3",{attrs:{id:"aof的写回策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof的写回策略"}},[s._v("#")]),s._v(" AOF的写回策略")]),s._v(" "),a("p",[s._v("在redis.conf中有以下配置：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# appendfsync always\nappendfsync everysec\n# appendfsync no\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[a("strong",[s._v("always")]),s._v("：同步写回，即每个命令执行完，立马同步地将日志写回磁盘")]),s._v(" "),a("li",[a("strong",[s._v("everysec")]),s._v("：每秒写回，"),a("strong",[s._v("默认写回策略")]),s._v("，即每个命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；")]),s._v(" "),a("li",[a("strong",[s._v("no")]),s._v("：由操作系统控制的写回，即每个命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘；")])]),s._v(" "),a("h4",{attrs:{id:"对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[s._v("#")]),s._v(" 对比")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("always")]),s._v("：这种策略很安全，能基本做到不丢失数据，但是每个写命令之后都有一个落盘的操作，所以对系统的影响是最大的；")]),s._v(" "),a("li",[a("strong",[s._v("no")]),s._v("：这种策略最不安全，因为落盘的时机不在redis手中，一旦发生宕机对应的数据就会丢失；")]),s._v(" "),a("li",[a("strong",[s._v("everysec")]),s._v("：避免了always策略的性能开销，也降低了no策略的丢失风险，最多可能会丢失1s的数据，它算是在二者之间取了个折中")])]),s._v(" "),a("h4",{attrs:{id:"如何选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选择"}},[s._v("#")]),s._v(" 如何选择")]),s._v(" "),a("ul",[a("li",[s._v("如果想要系统的高性能选 no策略")]),s._v(" "),a("li",[s._v("如果想要高可靠性就选择 always策略")]),s._v(" "),a("li",[s._v("如果二者兼容的话只有 everysec策略")])]),s._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),a("p",[s._v("这里虽然按照需求选择了写回策略，但是因为AOF是以文件形式记录接收到的命令的，"),a("strong",[s._v("随着写入命令的不断增加，AOF文件的体积会变得越来越大。")]),s._v("\n如果AOF文件太大，再往其中追加命令时，效率就会降低，而一旦发生宕机，用AOF恢复的速度也会非常慢。\n为了避免这种问题，AOF引入了重写机制")])]),s._v(" "),a("h3",{attrs:{id:"aof的重写机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof的重写机制"}},[s._v("#")]),s._v(" AOF的重写机制")]),s._v(" "),a("h4",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[s._v("#")]),s._v(" 概述")]),s._v(" "),a("p",[s._v("重写简单点说就是根据原有的AOF文件，重新创建一个新的AOF文件，只不过这个新的AOF文件体积比原来的更小。")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),a("p",[s._v("Redis的重写机制具有多变一的功能，也就是检查数据库的键值对，记录下键值对的最终状态，从而实现"),a("strong",[s._v("对某个键值对多次操作产生的多条命令压缩为一条的效果。")])])]),s._v(" "),a("p",[s._v("因为AOF文件是以追加的方式记录接收到的命令，当对一个键值对反复修改时，就会记录多条命令，然而在重写的时候只是记录下了当前的最新状态，这样就实现了多变一。\n一个问题：既然redis是单线程的，它既要执行写入命令，同时又要同步日志到磁盘，这里又出现这个重写机制，但它的响应速度依然很快，为什么？")]),s._v(" "),a("blockquote",[a("p",[s._v("redis为了避免阻塞主线程，导致性能下降，会创建一个子进程——"),a("code",[s._v("bgrewriteaof")]),s._v("，由这个子进程完成重写的过程")])]),s._v(" "),a("h4",{attrs:{id:"重写过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重写过程"}},[s._v("#")]),s._v(" 重写过程")]),s._v(" "),a("ol",[a("li",[s._v("首先，主线程fork出"),a("code",[s._v("bgrewriteaof")]),s._v("子进程，同时也会把主线程的内存拷贝一份给"),a("code",[s._v("bgrewriteaof")]),s._v("子进程，这里的拷贝指的是子进程复制了父进程页表，此时子进程就可以共享访问父进程的内存数据了；")]),s._v(" "),a("li",[s._v("然后，子进程将新的内容写入"),a("strong",[s._v("重写日志")]),s._v("；")]),s._v(" "),a("li",[s._v("对于新的操作命令，继续由父线程处理，redis会把这个操作记录到正在使用的AOF日志的缓冲区，这样一来就不用担心宕机问题，同样，也会在重写日志的缓冲区也记录一份；")]),s._v(" "),a("li",[s._v("当子进程完成重写工作之后，缓冲区里的这些新的操作也会记录到新的AOF文件中，此时，我们就可以用新的AOF文件替代旧文件了。")])]),s._v(" "),a("h4",{attrs:{id:"重写触发的时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重写触发的时机"}},[s._v("#")]),s._v(" 重写触发的时机")]),s._v(" "),a("ol",[a("li",[s._v("手动触发：手动发"),a("code",[s._v("bgrewriteaof")]),s._v("指令")]),s._v(" "),a("li",[s._v("自动触发：涉及到两个配置参数，"),a("strong",[s._v("只有AOF文件大小同时超出下面这两个配置项时，会触发AOF重写")]),s._v("：")])]),s._v(" "),a("ul",[a("li",[a("code",[s._v("auto-aof-rewrite-min-size")]),s._v("：AOF重写时文件的最小大小，默认为64MB；")]),s._v(" "),a("li",[a("code",[s._v("auto-aof-rewrite-percentage")]),s._v("：重写百分比，当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。")])]),s._v(" "),a("h2",{attrs:{id:"rdb快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb快照"}},[s._v("#")]),s._v(" RDB快照")]),s._v(" "),a("blockquote",[a("p",[s._v("RDB（Redis DataBase）内存快照，是"),a("strong",[s._v("redis默认的持久化方式")]),s._v("。具体就是"),a("strong",[s._v("将某一时刻的内存数据以文件的形式保存到磁盘上")]),s._v("。\n请注意，这里是"),a("strong",[s._v("保存的是数据！！！")]),s._v(" 不是操作。所以，在数据恢复的时候，我们就可以直接把RDB文件读入内存，快速完成恢复。")])]),s._v(" "),a("h3",{attrs:{id:"rdb相关配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb相关配置"}},[s._v("#")]),s._v(" RDB相关配置")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# 备份的频率：900秒内至少一个键被更改则进行快照\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# 快照创建出错后，是否继续执行写命令\nstop-writes-on-bgsave-error yes\n\n# 是否对快照文件进行压缩\nrdbcompression yes\n\n# 文件名称\ndbfilename dump.rdb\n\n# 文件保存位置\ndir ./\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("h3",{attrs:{id:"rdb持久化流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化流程"}},[s._v("#")]),s._v(" RDB持久化流程")]),s._v(" "),a("p",[s._v("首先我们要确认的是，我们在给内存数据库做快照的时候，做的是"),a("strong",[s._v("全量快照")]),s._v("，因为数据都在内存中，为了确保可靠性，就必须把内存中的所有数据都记录到磁盘中。\nRedis提供了两个命令来创建快照："),a("code",[s._v("save")]),s._v(" 和 "),a("code",[s._v("bgsave")])]),s._v(" "),a("ul",[a("li",[s._v("save：在主线程中执行RDB持久化，会导致阻塞；")]),s._v(" "),a("li",[s._v("bgsave：bgsave命令会fork一个子进程，专门用于写入RDB文件，避免了主线程的阻塞，这也是redis RDB文件生成的默认配置")])]),s._v(" "),a("blockquote",[a("p",[s._v("这个时候，我们就可以通过"),a("code",[s._v("bgsave")]),s._v("命令来执行全量快照，这样既提供了数据的可靠性保证，同时也避免了对redis性能的影响")])]),s._v(" "),a("p",[s._v("接下来，我们需要关注一个问题。在对内存数据做快照时，这些数据还能被修改吗？")]),s._v(" "),a("p",[s._v("如果能修改，意味着redis还能正常处理写操作，否则的话，就要等所有快照写完才能执行写操作，大大降低性能。")]),s._v(" "),a("p",[s._v("答案是："),a("strong",[s._v("在对内存数据做快照时，这些数据肯定还是可以被修改的。")])]),s._v(" "),a("p",[s._v("RDB采用"),a("strong",[s._v("写时复制(COW，copy on write)策略")]),s._v("，在执行快照的同时，正常处理写操作。")]),s._v(" "),a("p",[s._v("简单来说，Redis 在持久化时会调用glibc的函数fork，产生一个子进程，快照持久化此时就交给子进程来处理，父进程则继续处理客户端请求。子进程在做持久化的时候，不会对现有的内存数据结构进行修改，它只是进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续接受客户端请求，然后对内存数据结构进行修改。")]),s._v(" "),a("p",[s._v("如下图所示：如果主线程对数据是读操作，那么，主线程和子进程相互不影响。"),a("strong",[s._v("如果主线程要修改一块数据，那么这块数据就会被复制一份，生成该数据的副本")]),s._v("。然后主线程对这个副本进行修改。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://images.zaiolos.top/images/202208020923534.png",alt:"image.png"}})]),s._v(" "),a("p",[s._v("这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响")]),s._v(" "),a("h3",{attrs:{id:"快照的频率"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快照的频率"}},[s._v("#")]),s._v(" 快照的频率")]),s._v(" "),a("p",[s._v("为了提高系统的可靠性，防止宕机导致的数据丢失，我们肯定希望快照的时间越短越好。我们可能会想，通过bgsave子线程来执行快照，这样既不会阻塞主线程，同时也尽可能地少丢失数据。但是这样真的是完美的吗？\n答案是否定的。虽然 bgsave 执行时不阻塞主线程，但是如果"),a("strong",[s._v("频繁的执行全量快照也会有两方面的开销")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("频繁将全量数据写入磁盘，会给磁盘带来很大压力；")]),s._v(" "),a("li",[s._v("bgsave 子进程需要通过 fork 操作从主线程创建出来，虽然子进程在创建之后不会阻塞主线程，但是在"),a("strong",[s._v("fork的时候本身就会阻塞主线程")]),s._v("，如果频繁的调用fork创建子进程，就会频繁的阻塞主线程了。")])]),s._v(" "),a("p",[s._v("那么该如何处理呢？")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("处理方式")]),s._v(" "),a("p",[s._v("此时，我们可以做增量快照，也就是，"),a("strong",[s._v("在做了一次全量快照后，后续的快照只对修改的数据进行快照记录")]),s._v("，这样可以避免每次全量快照的开销。\n但是，这么做的前提是，"),a("strong",[s._v("我们需要记住哪些数据被修改了。这会带来额外的空间开销问题。")])])]),s._v(" "),a("h2",{attrs:{id:"两种持久化方式的对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#两种持久化方式的对比"}},[s._v("#")]),s._v(" 两种持久化方式的对比")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("对比")]),s._v(" "),a("ul",[a("li",[s._v("AOF每次记录的是操作命令，一般需要持久化的数据量不大。只要不是设置的always方式，对性能不会造成太大影响。但是在数据恢复时，需要把所有的命令都执行一遍。如果操作日志很多，redis恢复的速度就会很慢，可能会影响到正常使用。")]),s._v(" "),a("li",[s._v("而RDB快照的方式就弥补了这一点，它每次记录的是数据，redis在故障恢复的时候速度就会很快。但是，RDB的问题是，它执行快照的频率不好控制，如果频率太快会对系统带来性能影响，如果频率太慢就会造成更多的数据丢失。")])])]),s._v(" "),a("p",[s._v("那么，有没有方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？\n当然有，下面继续Redis 4.0 混合持久化。")]),s._v(" "),a("h2",{attrs:{id:"混合持久化-4-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#混合持久化-4-0"}},[s._v("#")]),s._v(" 混合持久化(4.0+)")]),s._v(" "),a("p",[s._v("混合持久化，就是将RDB文件的内容和增量的AOF日志文件存在一起。\n简单来说，"),a("strong",[s._v("内存快照是以一定频率执行的，那么在两次快照之间，使用AOF 日志记录发生的增量操作")]),s._v("。如下图所示：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://images.zaiolos.top/images/202208020939300.png",alt:"image.png"}})]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。")]),s._v(" "),a("li",[s._v("这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销")]),s._v(" "),a("li",[s._v("这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，提高了数据恢复效率，以及数据的可靠性。")]),s._v(" "),a("li",[s._v("在 Redis 重启的时候，可以先加载RDB的内容，然后再重放增量AOF日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。")])])])])}),[],!1,null,null,null);a.default=_.exports}}]);