---
title: 数组
date: 2022-03-01 09:19:30
permalink: /work/algorithm/array
categories:
  - 面试刷题
  - 刷题
tags:
  - 数组
---



## 数组相关题

### 1.(`easy`)移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

思路1：

> 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。
>
> 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
>
> 注意到以下性质：
>
> 左指针左边均为非零数；
>
> 右指针左边直到左指针处均为零。
>
> 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。
>



代码：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0;
        int right = 0;
        while (right < nums.length) {
            if (nums[right] != 0) {
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }

    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```





思路2：

> 使用双指针，左指针始终指向0的位置，右指针指向非0位置。
>
> - 如果当前左右指针都不为0，将两个指针都向后移一位
> - 如果左指针为0，右指针不为0，交换，将两个指针都向后移一位
> - 其他情况就只移动右指针即可



代码：

```java
public void moveZeroes(int[] nums) {
        int left = 0;
        int right = 0;
        while (right < nums.length) {
            if (nums[left] != 0 && nums[right] != 0) {
                left++;
            }
            else if(nums[left] == 0 && nums[right] != 0){
                swap(nums,left,right);
                left++;
            }
            right++;
        }
    }
```



### 2.(`medium`)和为K的子数组

给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

 

示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

输入：nums = [1,2,3], k = 3
输出：2



思路1：

> 很容易想到利用前缀和，得出每个[0,i]区间的子数组之和，然后[i,j]区间之和就等于[0,j]-[0,i]。
>
> 求出前缀和以后，枚举所有区间前缀和之差，等于k就res加一。
>
> 时间复杂度为O(n2)，空间复杂度O(1)
>
> 
>
> 我的比官方暴力要快几百ms

代码：

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        int[] preSum = new int[nums.length];
        preSum[0] = nums[0];
        for(int i = 1;i<nums.length;i++){
            preSum[i] = preSum[i-1]+nums[i];
        }
        for(int i = 0;i<preSum.length;i++){
            if(preSum[i] == k){
                res++;
            }
            for(int j = i+1;j<preSum.length;j++){
                if(preSum[j]-preSum[i] == k){
                    res++;
                }
            }
        }
        return res;
    }
}
```



思路2：

> 因为暴力的时间复杂度很高，我们可以利用hash表对算法进行优化。
>
> 暴力时我们使用的是 [0,j]-[0,i]==k 即是否存在两个前缀和之差等于k来寻找符合条件的[i,j]子数组。
>
> 
>
> 我们可以换个思路，使用一个HashMap<Integer,Integer>()，将前缀和以key存入HashMap，value为这种前缀和出现的次数，
>
> 比如k=7，数组为：0 7 2 5 3 -1，前缀和为：0 7 9 14 17 16，
>
> 我们要找前缀和之间差为7的，只需要去map里面找每个前缀和，有多少个与它之差为7的。
>
> 所以我们把每个前缀和以及它的数量存入map，找到key为 当前前缀和-k，的前缀和的数量让res加上即可在O(1)内获得结果
>
> 
>
> 这种思想的根本是，不是用区间(前缀和)去找差为K的区间数量，而是根据一个前缀和A，去找另一个满足A-B==K的前缀和B的数量

代码：

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        int pre = 0;
        HashMap<Integer,Integer> map = new HashMap<>();
        //先put一个0进去是为了nums[i]==k的情况，即只有一个元素的子数组
        map.put(0,1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            if(map.containsKey(pre-k)){
                res+=map.get(pre-k);
            }
            map.put(pre, map.getOrDefault(pre,0)+1);
        }
        return res;
    }
}
```



### 3.(`medium`)在排序数组中查找元素的第一个和最后一个位置

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {
            return new int[]{leftIdx, rightIdx};
        } 
        return new int[]{-1, -1};
    }

    public int binarySearch(int[] nums, int target, boolean lower) {
        int left = 0, right = nums.length - 1, ans = nums.length;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```



### 4.(`medium`)航班预订统计

这里有 n 个航班，它们分别从 1 到 n 进行编号。

有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。

请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。

 

示例 1：

输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
示例 2：

输入：bookings = [[1,2,10],[2,2,15]], n = 2
输出：[10,25]
解释：
航班编号        1   2
预订记录 1 ：   10  10
预订记录 2 ：       15
总座位数：      10  25
因此，answer = [10,25]



思路：

> 从题目例子不难看出，题目实际上就是给你一个长度为n，每个元素初始为0的int数组，让你对它进行多次[i,j,incr]操作，即对第i到第j个的值都加上incr(闭区间)，很容易想到差分数组。
>
> 差分数组即differ[i] = nums[i]-nums[i-1],i>=1 (`differ[0]=nums[0]本身`)
>
> 所以对差分数组求前缀和，可以得到原数组
>
> 举例:           i   j                    i   j 
>
> 原数组：     1 2 3 4 5 6 9  原差分数组：1 1 1 1 1 3
>
> ​                i   j                   i   j 
>
> 对第3-5个加2：1 2 5 6 7 6 9  增加后：   1 3 1 1 -1 3
>
> 从例子可以看出，对原数组的[i,j]区间的数进行同时增加，相当于对差分数组differ：differ[i]+=incr,differ[j+1]-=incr

代码：

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int count = bookings.length;
        int[] differ = new int[n];
        for(int i=0;i<count;i++){
            differ[bookings[i][0]-1] += bookings[i][2];
            if(bookings[i][1]<n){
                differ[bookings[i][1]] -= bookings[i][2];
            }
        }
        for(int i=1;i<n;i++){
            differ[i] += differ[i-1];
        }
        return differ;
    }
}
```

复杂度分析

- 时间复杂度：O(n+m)，其中 n 为要求的数组长度，m 为预定记录的数量。我们需要对于每一条预定记录处理一次差分数组，并最后对差分数组求前缀和。
- 空间复杂度：O(1)。我们只需要常数的空间保存若干变量，注意返回值不计入空间复杂度。
