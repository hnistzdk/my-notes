---
title: 二叉树
date: 2022-02-20 19:45:10
permalink: /work/algorithm/binaryTree
categories:
  - 面试刷题
  - 刷题
tags:
  - 二叉树
  - 算法
---

## 递归

> 写递归算法的关键是要明确函数的`定义`是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节

### 二叉树遍历框架

```java
void traverse(TreeNode root){
    if(root == null){
        return;
    }
    //前序遍历相关代码位置
    traverse(root.left);
    //中序遍历相关代码位置
    traverse(root.right);
    //后序遍历相关代码位置
}
```

### 其他数据结构的遍历

```java
/* 迭代遍历数组 */
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {

    }
}

/* 递归遍历数组 */
void traverse(int[] arr, int i) {
    if (i == arr.length) {
        return;
    }
    // 前序位置
    traverse(arr, i + 1);
    // 后序位置
}

/* 迭代遍历单链表 */
void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {

    }
}

/* 递归遍历单链表 */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    // 前序位置
    traverse(head.next);
    // 后序位置
}
```

> 单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，不过没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式

> `根结点是最顶上那个结点,金字塔的塔顶,叶子结点是最下面的结点,即没有子结点的结点`
>
> **前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：
>
> `前序位置的代码在刚刚进入一个二叉树节点的时候执行；`
>
> `后序位置的代码在将要离开一个二叉树节点的时候执行；`
>
> `中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。`



1. (`easy`)二叉树的前序遍历

   ```java
   class Solution {
       List<Integer> res = new ArrayList<>();
       public List<Integer> preorderTraversal(TreeNode root) {
           traverse(root);
           return res;
       }
       public void traverse(TreeNode root){
           if (root == null){
               return;
           }
           res.add(root.val);
           traverse(root.left);
           traverse(root.right);
       }
   }
   ```

   > res.add(root.val);即在刚进入二叉树结点时执行

2. (`easy`)二叉树的深度

   ```java
   class Solution {
       int res = 0;
       int curDepth = 0;
       public int maxDepth(TreeNode root) {
           traverse(root);
           return res;
       }
       public void traverse(TreeNode root){
           if (root == null){
               res = Math.max(res, curDepth);
               return;
           }
           curDepth++;
           traverse(root.left);
           traverse(root.right);
           curDepth--;
       }
   }
   ```

   > 利用curDepth维护当前所在位置的深度，每到达一个结点curDepth++，离开该结点时，curDepth--，到达叶子结点后，更新一下最大深度

3. (`easy`)翻转二叉树

   >  核心思路是将每个结点的左右子结点交换即可，可以在前序位置或后续位置进行交换，最后返回root即可

   ```java
   class Solution {
       public TreeNode invertTree(TreeNode root) {
           if (root == null){
               return null;
           }
           TreeNode temp = root.left;
           root.left = root.right;
           root.right = temp;
           invertTree(root.left);
           invertTree(root.right);
           return root;
       }
   }
   ```

4. (`mid`)二叉树的层序遍历

   - 迭代方式

     > 利用队列按从左到右的顺序储存每一层的所有结点，每次for循环将这些结点组合成List< Integer>,添加到res列表中，`注意的是，for循环的次数，是当前这次while循环中队列的size()`，而不是直接队列的size()；
     >
     > 每次while循环用于控制层数

     ```java
     class Solution {
         public List<List<Integer>> levelOrder(TreeNode root) {
             List<List<Integer>> res = new ArrayList<>();
             if (root == null){
                 return res;
             }
             Deque<TreeNode> nodeDeque = new LinkedList<>();
             nodeDeque.push(root);
             while (!nodeDeque.isEmpty()){
                 //对当前队列中的每个结点进行处理
                 List<Integer> temp = new ArrayList<>();
                 //当前层的结点数量
                 int curLen = nodeDeque.size();
                 for (int i = 0; i < curLen; i++) {
                     TreeNode curNode = nodeDeque.pop();
                     temp.add(curNode.val);
                     //把当前结点的左右子结点都入队列
                     if (curNode.left != null){
                         nodeDeque.add(curNode.left);
                     }
                     if (curNode.right != null){
                         nodeDeque.add(curNode.right);
                     }
                 }
                 res.add(temp);
             }
             return res;
         }
     }
     ```

5. (`mid`)N叉树的层序遍历

   - 迭代方式

     > 同二叉树的层序遍历类似，只是结点的结构换成了
     >
     > ```java
     > class Node {
     >     public int val;
     >     public List<Node> children;
     > 
     >     public Node() {}
     > 
     >     public Node(int _val) {
     >         val = _val;
     >     }
     > 
     >     public Node(int _val, List<Node> _children) {
     >         val = _val;
     >         children = _children;
     >     }
     > }
     > ```
     >
     > 只需改变入队列时的对象为当前结点的每个子结点即可

     代码：

     ```java
     class Solution {
         public List<List<Integer>> levelOrder(Node root) {
             List<List<Integer>> res = new ArrayList<>();
             if (root == null){
                 return res;
             }
             Deque<Node> nodeDeque = new LinkedList<>();
             nodeDeque.push(root);
             while (!nodeDeque.isEmpty()){
                 //对当前队列中的每个结点进行处理
                 List<Integer> temp = new ArrayList<>();
                 int curLen = nodeDeque.size();
                 for (int i = 0; i < curLen; i++) {
                     Node curNode = nodeDeque.pop();
                     temp.add(curNode.val);
                     List<Node> children = curNode.children;
                     for (int j = 0; j < children.size(); j++) {
                         //把当前结点的所有子结点都入队列
                         nodeDeque.add(children.get(j));
                     }
                 }
                 res.add(temp);
             }
             return res;
         }
     }
     ```

6. (`mid`)给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

   ```
   struct Node {
     int val;
     Node *left;
     Node *right;
     Node *next;
   }
   ```

   填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

   初始状态下，所有 next 指针都被设置为 `NULL`。

   

   **示例 1：**

   ![img](https://gitee.com/hnistzdk/picture/raw/master/images/202202222101883.png)

   ```
   输入：root = [1,2,3,4,5,6,7]
   输出：[1,#,2,3,#,4,5,6,7,#]
   解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
   ```

   

   **示例 2:**

   ```
   输入：root = []
   输出：[]
   ```

   

   **提示：**

   - 树中节点的数量在 `[0, 212 - 1]` 范围内
   - `-1000 <= node.val <= 1000`

   

   **进阶：**

   - 你只能使用常量级额外空间。

   - 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

     

   `解题思路：`

   - 利用层序遍历

     > 利用二叉树层序遍历的思想，将每层的每两个左右结点之间由左连到右

     ```java
     /*
     // Definition for a Node.
     class Node {
         public int val;
         public Node left;
         public Node right;
         public Node next;
     
         public Node() {}
     
         public Node(int _val) {
             val = _val;
         }
     
         public Node(int _val, Node _left, Node _right, Node _next) {
             val = _val;
             left = _left;
             right = _right;
             next = _next;
         }
     };
     */
     
     class Solution {
         public Node connect(Node root) {
             if (root == null){
                 return root;
             }
             Node res = root;
             LinkedList<Node> nodeDeque = new LinkedList<>();
             nodeDeque.push(root);
             while (!nodeDeque.isEmpty()){
                 //对当前队列中的每个结点进行处理
                 Node left = nodeDeque.get(0);
                 for (int i = 1; i < nodeDeque.size(); i++){
                     //每个左边的结点都和它右边的连上 不管是在同一结点上还是跨结点
                     left.next = nodeDeque.get(i);
                     //连上以后 将右边的结点作为左结点 继续连
                     left = nodeDeque.get(i);
                 }
                 int curLen = nodeDeque.size();
                 for (int i = 0; i < curLen; i++) {
                     Node curNode = nodeDeque.pop();
                     //把当前结点的左右子结点都入队列
                     if (curNode.left != null){
                         nodeDeque.add(curNode.left);
                     }
                     if (curNode.right != null){
                         nodeDeque.add(curNode.right);
                     }
                 }
             }
             return res;
         }
     }
     ```

   - 使用递归

     > 先将在同一父节点下的两个结点连接好，然后连接不同父节点的结点。
     >
     > 因为连接不同父节点的结点时，同一父节点下的两个结点已经被连接好了，而根据题目定义，我们只需要将已个有子节点的结点的右子节点与另一个有子节点的结点的左结点连接起来就行了

     ```java
     class Solution {
         public Node connect(Node root) {
             if (root == null){
                 return root;
             }
             connectTwo(root.left,root.right);
             return root;
         }
         public void connectTwo(Node node1,Node node2){
             if (node1 == null || node2 == null) {
                 return;
             }
             node1.next = node2;
             connectTwo(node1.left,node1.right);
             connectTwo(node2.left, node2.right);
             connectTwo(node1.right, node2.left);
         }
     }
     ```

7. (`easy`)二叉树的直径

   > 我们知道，二叉树的直径为左右子树最大深度之和，问题转化为求子树最大深度，然后取直径与深度之和的max即可。
   >
   > 使用后序遍历，定义int maxDepth方法返回每个结点的最大深度，在方法中的后序遍历代码位置，取直径与深度之和的max

   ```java
   class Solution {
       int diameter = 0;
       public int diameterOfBinaryTree(TreeNode root) {
           maxDepth(root);
           return diameter;
       }
   
       public int maxDepth(TreeNode root){
           if (root == null){
               return 0;
           }
           int leftMaxDepth = maxDepth(root.left);
           int rightMaxDepth = maxDepth(root.right);
           //计算直径
           diameter = Math.max(diameter,leftMaxDepth+rightMaxDepth);
   
           //返回深度 加1是加上根节点自己
           return 1+Math.max(leftMaxDepth, rightMaxDepth);
       }
   }
   ```

8. （`easy`）对称二叉树：给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

   - 使用层序遍历，比较每一层是否轴对称

     > 使用层序遍历比较每一层是我们容易想到的方法，但要注意的是，题目要求的是中心对称，在使用中序遍历的时候
     >
     > ![img](https://gitee.com/hnistzdk/picture/raw/master/images/202202252025320.jpeg)
     >
     > 这种情况，中序遍历得到的结果是23132，进行判断的话是满足对称的，所以我们将缺一个子节点的二叉树补全成完全的二叉树，得到的结果：101 2 3 1 101 2 3，就可以区分这种情况了

     代码:

     ```java
     class Solution {
         public boolean isSymmetric(TreeNode root) {
             Deque<TreeNode> nodeDeque = new LinkedList<>();
             nodeDeque.push(root.left);
             nodeDeque.push(root.right);
             int count = 0;
             while (!nodeDeque.isEmpty()){
                 //对当前队列中的每个结点进行处理
                 Deque<Integer> res = new LinkedList<>();
                 int curLen = nodeDeque.size();
                 for (int i = 0; i < curLen; i++) {
                     TreeNode curNode = nodeDeque.pop();
                     //如果当前结点为空 就会加入101
                     if (curNode == null){
                         res.add(101);
                         continue;
                     }else{
                         res.add(curNode.val);
                         //结点放进去
                         nodeDeque.add(curNode.left);
                         nodeDeque.add(curNode.right);
                     }
                 }
                 while (!res.isEmpty()){
                     Integer first = res.pollFirst();
                     Integer last = res.pollLast();
                     if (first==null || last==null){
                         return false;
                     }
                     if (first != last){
                         return false;
                     }
                 }
             }
             return true;
         }
     }
     ```

   - 使用递归：

     > 
