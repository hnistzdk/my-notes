---
title: 多线程进阶-JMM
date: 2022-01-06 11:51:06
permalink: /java/se/thread/3
categories:
  - Java
  - Java-多线程
tags:
  - 多线程
  - JMM
---
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [3、JMM(Java Memory Model)](#3jmmjava-memory-model)
    - [JMM的三个特征](#jmm%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E5%BE%81)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

---

## 3、JMM(Java Memory Model)

> 什么是JMM？
>
> JMM：java内存模型，是概念、约定
>
> **关于JMM多线程的一些同步的约定：**
>
> 1. 线程解锁前，必须把共享变量的值**立刻刷新回主存**
> 2. 线程加锁前，必须读取主存中的共享变量的最新值到工作内存中
> 3. 加锁和解锁必须是同一把锁



**主内存和本地内存结构**

> 从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。本地内存它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化之后的一个数据存放位置
>
> 
>
> ![image-20211113210457626](https://images.zaiolos.top/images/202201061159316.png)
>
> 从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：
>
> 1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
> 2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。
>
> ![image-20211113210516306](https://images.zaiolos.top/images/image-20211113210516306.png)
>
> 
>
> 如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。
>
> 从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。
> ![image-20211113210346273](https://images.zaiolos.top/images/202201061159419.png)



内存交互操作有8种，**如上图**，虚拟机实现必须保证每一个操作都是原子的，不可再分的(对于long和double类型的变量来说，load、store、read和write操作在某些平台上允许例外)

- - lock（锁定）︰作用于主内存的变量，把一个变量标识为线程独占状态
  - unlock (解锁）∶作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变呈才可以被其他线程锁定
  - read（读取）∶作用于主内存变呈，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
  - load（载入）︰作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
  - use(使用):作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
  - assign(赋值）∶作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变呈副本中
  - store(存储）∶作用于主内存中的变量，它把一个从工作内存中一个变呈的值传送到主内存中，以便后续的write使用
  - write(写入）∶作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

  JMM对这八种指令的使用，制定了如下规则：

- - 不允许read和load、store和write操作之一单独出现。即使用了read必须load,使用了store必须write
  - 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
  - 不允许一个线程将没有assign的数据从工作内存同步回主内存
  - 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作前，必须经过assign和load操作
  - 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
  - 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assig操作初始化变量的值
  - 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
  - 对一个变量进行unlock操作之前，必须把此变量同步回主内存



#### JMM的三个特征

> java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的

1. **原子性**

   > 一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。

   > 基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。

2. **可见性**

   > 一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量的这种修改（变化）。

   > Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。
   >
   > 无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。
   >
   > 除了volatile关键字能实现可见性之外，还有**synchronized,Lock，final**也是可以的。
   >
   > **使用synchronized关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）**。
   >
   > **使用Lock接口的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。**
   >
   > **final关键字的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去（“this”引用逃逸是很危险的，其他的线程很可能通过该引用访问到只“初始化一半”的对象），那么其他线程就可以看到final变量的值。**

3. **有序性**

   > 对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。

   > 一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。
   >
   > Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现，
   >
   > 在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。

