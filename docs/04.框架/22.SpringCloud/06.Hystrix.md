---
title: Hystrix
date: 2022-10-28 17:01:32
permalink: /SpringCloud/Hystrix/
categories:
  - 框架
  - SpringCloud
tags:
  - Hystrix
---
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Hystrix](#hystrix)
  - [概述](#%E6%A6%82%E8%BF%B0)
    - [分布式系统面临的问题](#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98)
      - [服务雪崩](#%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9)
    - [是什么](#%E6%98%AF%E4%BB%80%E4%B9%88)
    - [能干嘛](#%E8%83%BD%E5%B9%B2%E5%98%9B)
    - [官方资料](#%E5%AE%98%E6%96%B9%E8%B5%84%E6%96%99)
  - [Hystrix重要概念](#hystrix%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5)
    - [服务降级(fallback)](#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7fallback)
      - [哪些情况会触发降级](#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E8%A7%A6%E5%8F%91%E9%99%8D%E7%BA%A7)
    - [服务熔断(break)](#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%ADbreak)
    - [服务限流(flowlimit)](#%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81flowlimit)
  - [Hystrix案例](#hystrix%E6%A1%88%E4%BE%8B)
    - [pom](#pom)
    - [yaml](#yaml)
    - [service](#service)
    - [controller](#controller)
    - [测试](#%E6%B5%8B%E8%AF%95)
  - [Hystrix工作流程](#hystrix%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B)
  - [服务监控 Hystrix Dashboard](#%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7-hystrix-dashboard)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

---

# Hystrix

## 概述

### 分布式系统面临的问题

> **复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败**。

#### 服务雪崩

> 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的**“扇出”**。**如果扇出的链路上某个微服务的调用响应时间过长或者不可用**，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。
>
> <br/>
>
> 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列、线程和其他系统资源紧张，进而导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。

### 是什么

> Hystrix是一个用于处理分布式系统的**延迟**和**容错**的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，**不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性**。
>
> <br/>
>
> "断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控〔类似熔断保险丝)，**向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常**，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

### 能干嘛

- 服务降级

- 服务熔断

- 接近实时的监控

### 官方资料

wiki:

**https://github.com/Netflix/Hystrix/wiki/How-To-Use**

Hystrix已停止更新，进入仅维护状态



## Hystrix重要概念

### 服务降级(fallback)

- 服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback

#### 哪些情况会触发降级

- 程序运行异常
- 超时
- 服务熔断触发服务降级
- 线程池/信号量打满

### 服务熔断(break)

> 类比保险丝，在达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。
>
> 服务降级->进而熔断->一段时间再恢复正常调用

### 服务限流(flowlimit)

> 限制访问量(秒杀等高并发操作)

## Hystrix案例

新建cloud-provider-hystrix-payment8001工程

### pom

新增hystrix的依赖即可

> 这里由于cloud2020已经没有hystrix的版本了，所以需要自己加一个引入

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
    <version>2.2.10.RELEASE</version>
</dependency>
```

### yaml

```yaml
server:
  port: 8001

# 服务名称  （必写）
spring:
  application:
    name: cloud-payment-hystrix-service

eureka:
  client:
    # false表示不想注册中心注册自己
    register-with-eureka: true
    # false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要检查服务
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/
```

### service

```java
package com.zdk.springcloud.service;

import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

/**
 * @Description
 * @Author zdk
 * @Date 2022/10/28 18:03
 */
@Service
public class HystrixPaymentService {

    public String paymentInfoOk(Integer id){
        return "线程池："+Thread.currentThread().getName()+" paymentInfoOk,id:  "+id+"\t"+"欧克欧克";
    }

    public String paymentInfoTimeout(Integer id){
        int time = 3;
        try {
            TimeUnit.SECONDS.sleep(time);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return "线程池："+Thread.currentThread().getName()+" paymentInfoTimeout,id:  "+id+"\t"+"欧克欧克 耗时："+time+"秒";
    }
}
```

### controller

```java
package com.zdk.springcloud.controller;

import com.zdk.springcloud.service.HystrixPaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Description
 * @Author zdk
 * @Date 2022/10/28 18:07
 */
@Slf4j
@RestController
public class HystrixPaymentController {

    @Autowired
    private HystrixPaymentService hystrixPaymentService;

    @Value("${server.port}")
    private String serverPort;

    @GetMapping("/payment/hystrix/ok/{id}")
    public String paymentInfoOk(@PathVariable Integer id){
        String result = hystrixPaymentService.paymentInfoOk(id);
        log.info("*****result："+result);
        return result;
    }

    @GetMapping("/payment/hystrix/timeout/{id}")
    public String paymentInfoTimeout(@PathVariable Integer id){
        String result = hystrixPaymentService.paymentInfoTimeout(id);
        log.info("*****result："+result);
        return result;
    }
}

```

### 测试

启动eureka7001，再启动此8001payment，访问测试

![image-20221028181523002](https://images.zaiolos.top/images/202210281815070.png)

目前访问正常



## Hystrix工作流程



## 服务监控 Hystrix Dashboard
