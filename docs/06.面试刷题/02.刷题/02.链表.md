---
title: 链表
date: 2022-02-22 16:32:55
permalink: /work/algorithm/LinkedList
categories:
  - 面试刷题
  - 刷题
tags:
  - 链表
---

## 链表题



### 1.(`easy`)反转链表

- 使用栈

  > 将结点依次入驻完然后出栈即可实现反转。
  >
  > 注意：要保存新的头结点的值，不能直接用头结点去拼接结点(使用dummy结点)

  ```java
  class Solution {
      public ListNode reverseList(ListNode head) {
          Deque<ListNode> stack = new LinkedList<>();
          while(head!=null){
              stack.push(head);
              head = head.next;
          }
          ListNode res = new ListNode();
          ListNode dummy = new ListNode(-1);
          res = dummy;
          while(!stack.isEmpty()){
              res.next = stack.pop();
              res = res.next;
          }
          res.next = null;
          return dummy.next;
      }
  }
  ```

- 迭代

  > 思路就是逆转相邻两结点的next指向即可

  ```java
  class Solution {
      public ListNode reverseList(ListNode head) {
          ListNode pre = null;
          ListNode cur = head;
          while(cur != null){
              ListNode next = cur.next;
              cur.next = pre;
              pre = cur;
              cur = next;
          }
          return pre;
      }
  }
  ```

- 使用递归

  > `reverseList` 函数定义是这样的：
  >
  > **输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的头结点**。

  ```java
  class Solution {
      public ListNode reverseList(ListNode head) {
          if (head == null || head.next == null){
              return head;
          }
          ListNode last = reverseList(head.next);
          head.next.next = head;
          head.next = null;
          return last;
      }
  }
  ```



### 2.(`medium`)反转链表||

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。



思路：

> 交换前：
> - 使用哑结点，以便头结点的交换。
> - 找到左节点的前一个结点、左节点、右节点、右节点的后一个结点。 
> -  然后交换区间内的right-left+1个结点的位置，需要交换right-left次。
> -  交换前需要直接将当前第一个结点cur(即初始左节点)的next指向右节点的后一个结点;
> -  将cur的前一个结点的next指向右节点。
>
> 交换：
> - 将要交换的第二个结点标记。
> -  使用temp结点来储存这第二个结点的后一结点，便于第二结点后移
> -  然后让第二个结点next指向cur，cur移动到next，next移动到temp
>
> ![在这里插入图片描述](https://gitee.com/hnistzdk/picture/raw/master/images/202202281543321.png)



代码：

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        int index = 1;
        ListNode preNode = null;
        ListNode postNode = null;
        ListNode leftNode = null;
        ListNode rightNode = null;
        ListNode temp = dummy;
        for (int i = 0; i < left-1; i++) {
            temp = temp.next;
        }
        preNode = temp;
        leftNode = temp.next;
        for (int i = 0; i < right-left+1; i++) {
            temp = temp.next;
        }
        rightNode = temp;
        postNode = temp.next;

        //将要反转的这个区间里的链表截断
        preNode.next = null;
        rightNode.next = null;

        //将区间链表反转
        ListNode pre = null;
        ListNode cur = leftNode;
        while (cur!=null){
            //现结点的后一个结点
            ListNode next = cur.next;
            //现在的结点的next指向它的前一个结点
            cur.next = pre;
            //反转一次后 前结点后移
            pre = cur;
            //现结点也后移
            cur = next;
        }
        //将原left左边的结点接到要反转的最右结点上
        preNode.next = rightNode;
        //将要反转的最左结点,接到原右节点的位置
        leftNode.next = postNode;
        return dummy.next;
    }
}
```



### 3.(`easy`)相交链表

给你两个单链表的头节点 headA 和 headB,请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

![image-20220305191129288](https://gitee.com/hnistzdk/picture/raw/master/images/202203051911340.png)



提示：

- listA 中节点数目为 m
- listB 中节点数目为 n
- 1 <= m, n <= 3 * 104
- 1 <= Node.val <= 105
- 0 <= skipA <= m
- 0 <= skipB <= n
- 如果 listA 和 listB 没有交点，intersectVal 为 0
- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]



思路1：

> 目标是找相交结点，即找两条链表中相同的结点，可以使用一个hash表遍历储存链表A中的结点，然后遍历链表B，如果遍历到有结点在hash表中存在，这个结点就是交点。否则等遍历完后，返回null

代码：

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        HashMap<ListNode,Integer> map = new HashMap<>();
        while(headA!=null){
            map.put(headA,1);
            headA = headA.next;
        }
        while(headB!=null){
            if(map.containsKey(headB)){
                return headB;
            }
            headB = headB.next;
        }
        return null;
    }
```



思路2：

> 设「第一个公共节点」为 node ，「链表 headA」的节点数量为 a ，「链表 headB」的节点数量为 b ，「两链表的公共尾部」的节点数量为 c ，则有：
>
> 头节点 headA 到 node 前，共有 a - c个节点；
> 头节点 headB 到 node 前，共有 b - c个节点；
>
> 考虑构建两个节点指针 A , B 分别指向两链表头节点 headA , headB ，做如下操作：
>
> 指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：
> 									a+(b−c)
>
> 指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：
> 									b+(a−c)
>
> 如下式所示，此时指针 A , B 重合，并有两种情况：
> 								a+(b−c)=b+(a−c)
>
> 若两链表 有 公共尾部 (即c>0) ：指针 A , B 同时指向「第一个公共节点」node 。
> 若两链表 无 公共尾部 (即c=0) ：指针 A , B 同时指向 null 。
> 因此返回 A 即可。

代码：

```java
 public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A = headA;
        ListNode B = headB;
        while(A!=B){
            A = A==null?headB:A.next;
            B = B==null?headA:B.next;
        }
        return A;
    }
```

