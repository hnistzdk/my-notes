---
title: 网络
date: 2022-02-26 11:35:23
permalink: /work/interview/network
categories:
  - 面试刷题
  - 面试
tags:
  - 
---

## 重点

1. TCP/IP协议体系的认知
2. 链路层
    1. 以太网帧的格式
    2. MTU的概念
    3. ARP协议和RARP协议（掌握一下ARP缓存的原理）
4. 网络层
    1. 掌握IP的首部格式
    2. 掌握IP的分片
    4. 掌握IP选路
    5. ICMP协议
        1. 掌握报文格式
        2. 分类：查询 + 差错
        3. 两种 + 五种
4. 传输层
    1. UDP，次要一点，掌握特点和首部各个字段
    2. 掌握TCP
        1. 特点 + 首部字段 + 可靠机制
        2. 连接控制 ： 三次握手，四次挥手，同时打开，同时关闭，半关闭（可能问到为什么需要）
        3. 流量控制机制：滑动窗口,慢启动，拥塞避免，快速重传，快速恢复
        4. 超时重传机制：各种定时器
5. 应用层
    1. 掌握DNS协议
        1. 名字空间
        2. 指针查询（反向查找或逆向解析）基本原理
        3. DNS缓存
    2. FTP协议（活化石）：
        1. 控制流和数据流
        2. 两种工作模式： PASV 和 PORT
        3. 各种指令和响应码
        4. 断点续传和匿名FTP的概念
    5. HTTP协议： 
        1. 报文格式：请求报文，响应报文，请求头各种字段，响应头各种字段
        2. HTTP状态码
    2. HTTPS协议
        1. 握手的详细过程
        2. 摘要算法，数字签名，数字证书的原理和过程

## 1.TCP三次握手

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。



刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。
进行三次握手：



- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。

  首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于`SYN_RCVD`的状态。

  在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于`ESTABLISHED`状态。服务器收到 ACK 报文之后，也处于`ESTABLISHED`状态，此时，双方已建立起了连接。

  确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。

在socket编程中，客户端执行connect()时，将触发三次握手。

![image-20220305195012960](https://gitee.com/hnistzdk/picture/raw/master/images/202203051950001.png)



### 1.1为什么需要三次握手，两次不行吗？

弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

- 第一次握手：客户端发送网络包，服务端收到了。
  这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

- 第二次握手：服务端发包，客户端收到了。
  这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

- 第三次握手：客户端发包，服务端收到了。
  这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

  因此，需要三次握手才能确认双方的接收与发送能力是否正常。

  

试想如果是用两次握手，则会出现下面这种情况：

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在`某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端`，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。



### 1.2 什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个`队列`里，我们把这种队列称之为`半连接队列`。



当然还有一个`全连接队列`，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。



这里在补充一点关于`SYN-ACK 重传次数`的问题：
服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…





### 1.3 ISN(Initial Sequence Number)是固定的吗？

当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

**三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。**



### 1.4 三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。**



### 1.5 SYN攻击是什么？

> 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。



检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstat 命令来检测 SYN 攻击。

```shell
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术



## 2.TCP四次挥手

建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。



TCP 连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。



刚开始双方都处于`ESTABLISHED`状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
  即发出`连接释放报文段`（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入`FIN_WAIT1`（终止等待1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于` CLOSE_WAIT `状态。
  即服务端收到连接释放报文段后即发出`确认报文段`（ACK=1，确认号ack=u+1，序号seq=v），服务端进入`CLOSE_WAIT`（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入`FIN_WAIT2`（终止等待2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。
  即服务端没有要向客户端发出的数据，服务端发出`连接释放报文段`（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入`LAST_ACK`（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于` TIME_WAIT `状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 `CLOSED` 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于` CLOSED` 状态。
  即客户端收到服务端的连接释放报文段后，对此发出`确认报文段`（ACK=1，seq=u+1，ack=w+1），客户端进入`TIME_WAIT`（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入`CLOSED`状态。



收到一个FIN只意味着在这一方向上没有数据流动。**客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。**

在socket编程中，任何一方执行close()操作即可产生挥手操作。

![image-20220305200112685](https://gitee.com/hnistzdk/picture/raw/master/images/202203052001727.png)



### 2.1 挥手为什么需要四次？

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。



### 2.2 2MSL等待状态

> **MSL**是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

> TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。
>
> 对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。
>
> 这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。



### 2.3 四次挥手释放连接时，等待2MSL的意义？

> 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

#### 两个理由：

1. **保证客户端发送的最后一个ACK报文段能够到达服务端**。

   > 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。

2. **防止“已失效的连接请求报文段”出现在本连接中**。

   > 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。



### 2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

> 理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以**TIME_WAIT状态就是用来重发可能丢失的ACK报文**。



### 2.5 TCP状态变迁图

![TCP状态变迁图.jpg](https://gitee.com/hnistzdk/picture/raw/master/images/202203052006278.png)





## 3.TCP和UDP是什么

> TCP：
> 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。

> UDP：
> Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。

## 4.TCP和UDP有什么区别

1. TCP面向连接，通过三次握手建立连接，四次挥手接除连接;UDP是无连接的，即发送数据之前不需要建立连接，这种方式为UDP带来了高效的传输效率，但也导致无法确保数据的发送成功。
2. TCP是可靠的通信方式。通过TCP连接传送的数据，TCP通过超时重传、 数据校验等方式来确保数据无差错，不丢失，不重复，且按序到达；而UDP由于无需连接的原因，将会以最大速度进行传输，但不保证可靠交付，也就是会出现丢失、重复等等问题。
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，由于连接的问题，当网络出现波动时，连接可能出现响应问题；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。
4. 每一条TCP连接只能是点到点的；而UDP不建立连接，所以可以支持一对一，一对多，多对一和多对多的交互通信，也就是可以同时接受多个人的包。
5. TCP需要建立连接，首部开销20字节相比8个字节的UDP显得比较大。
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

## 5.TCP维护可靠的通信方式

1. 数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；
2. 到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认包；
3. 超时重发：发送方在发送分片后计时，若超时却没有收到相应的确认包，将会重发对应的分片；
4. 滑动窗口：TCP连接双方的接收缓冲空间大小都固定，接收端只能接受缓冲区能接纳的数据。
5. 失序处理：TCP的接收端需要重新排序接收到的数据。
6. 重复处理：如果传输的TCP分片出现重复，TCP的接收端需要丢弃重复的数据。
7. 数据校验：TCP通过保持它首部和数据的检验和来检测数据在传输过程中的任何变化。



## 6.TCP/IP的流量控制

1. 需要流量控制的原因

   > 数据发送的过快接受放来不及接受会造成数据丢书

2. 如何控制

   > 让发送方的发生速率不要太快，接收方来得及接受

3. 具体：滑动窗口机制，窗口指发送未收到确认的数据段都在这里

   - 由接收方控制流量，收到的数据会发送确认，确认之后发送方的窗口会向前滑动发送接下来的字节
   - 当接收方没有内存会告诉发送方能接受的字节为0 ，但是这个消息可能会丢失，丢失之后发送方和接收方都会一直等待对方发送数据，会形成死锁
   - 首先如果接收方收到0字节通知会启动一个持续计时器，计时器超时的话会发送一个0窗口探测报文，接收方收到就会返回自己现在能接受的数据大小，死锁解除，如果还是0就再开启一个计时器
   - 如果零窗口探测报文丢失的话，也有一个计时器，这个计时器超时探测报文也会重传

### 6.1 滑动窗口机制

**滑动窗口通俗来讲就是一种流量控制技术**

它**本质上是描述接收方的TCP数据报缓冲区大小的数据**，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来



所谓滑动窗口协议，自己理解有两点：1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。在引入一个例子来说这个协议之前，我觉得很有必要先了解以下前提：

1. TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收），我们以A发送B接收的情况作为例子；
2. 发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；
3. 发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；
4. 每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送；

TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为‘20’：
字节31-50为发送窗口

![img](https://gitee.com/hnistzdk/picture/raw/master/images/202203052030185.png)



A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组：

![img](https://gitee.com/hnistzdk/picture/raw/master/images/202203052030145.png)

只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递：

![img](https://gitee.com/hnistzdk/picture/raw/master/images/202203052030051.png)



如果出现丢包现象：（如图中的7、8、9丢失）

![img](https://gitee.com/hnistzdk/picture/raw/master/images/202203052031396.png)



`B给A发确认号为7，确认数据包中有“选择性确认段”，此时A只发送丢失的7-9，而不会再发10-12。`

### 6.2 传递效率

> 一个显而易见的问题是：单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，无疑增加了网络中的许多不必要的报文（请想想为了一个字节数据而添加的40字节头部吧！），所以我们的原则是尽可能一次多发送几个字节，或者窗口空余较多的时候通知发送方一次发送多个字节。对于前者我们广泛使用Nagle算法，即：
>
> 1. 若发送应用进程要把发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来；
> 2. 当发送方收到第一个字节的确认后（也得到了网络情况和对方的接收窗口大小），再把缓冲区的剩余字节组成合适大小的报文发送出去；
> 3. 当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；对于后者我们往往的做法是让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。



## 7.拥塞控制

### 7.1 什么是拥塞？什么是拥塞控制？

> 在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就称为**拥塞**。简单的说**拥塞产生的原因有两点：**（1）接收方容量不够（2）网络内部有瓶颈

> **拥塞控制**就是防止过多的数据注入到网络中，这样可以使网络中的`路由器或链路`不致过载。

### 7.2 检测网络拥塞的方法？

> 1. 发送数据后规定时间没有收到回应可以判定堵塞
>
> 2. 发送数据后收到同一条报文的四次确认，可认为丢失-------------这种情况就是根据TCP传输数据的特点：发送12345个数据段，接受端收到1的时候会返回2的确认报文也就是说我收到了2之前的下一次我就想要2了--------收到2之后返回3的确认报文------但是现在3迟迟未到-------4到了储存下来还是返回3的确认---5到了还是如此----然后3才到又发现缓存里面有45就返回6的确认报文表示之前的我都收到了，
>
>    若发送方接收到对同一条报文的三次冗余确认（也就是四次确认），就认为这条报文的下一条已经丢失，于是不管计时器是否超时，都直接重传这条报文的下一条。快速重传的条件发生，发送方将认为出现了拥塞导致丢包。
>
>    所以TCP判断拥塞就是判断有没有丢包

### 7.3 网络拥塞的表现？

> 主机ab通话，由主机a发送数据给主机b的时候不是直达，而是通过网络中的路由器等等，-----
>
> 路由器先储存这些数据，然后再从中取出，根据数据中的地址转发给下一个离主机b近的路由器或者直接到达主机b-----
>
> 有一个问题就是路由器的内存是有限的，如果同一时间到达的数据太多路由器接受不了就只能丢弃一部分，或者路由器数据本来就多后来的数据就要等很长时间才能转发
>
> **所以网络中数据太多，路由器处理不过来或者太慢就是网络拥塞**



### 7.4 TCP/IP协议的拥塞控制？

`TCP`进行拥塞控制的四种算法：慢开始、拥塞避免、快速重传、快速恢复。

- **MSS**：最大报文段长度，`TCP`双方发送的报文段中，包含的数据部分的最大字节数；
- **cwnd**：拥塞窗口，`TCP`发送但还没有得到确认的报文的序号都在这个区间；
- **RTT**：往返时间，发送方发送一个报文，到接收这个报文的确认报文所经历的时间；
- **ssthresh**：慢启动阈值，慢启动阶段，若`cwnd`的大小达到这个值，将转换到拥塞避免模式；

**三种模式要相互转换**

例如初始cwnd=1 ssthresh=16

1. 慢启动

   每传一次数据cwnd指数增长：2、4、8、16

   当cwnd=ssthresh=16的时候就变成拥塞避免

2. 拥塞避免

   这个时候每传一次数据cwnd+1，线性增长，当cwnd=24的时候如果一直没有接收到回应那可以认为发送拥塞了就会超时重传，这个时候

   ssthresh=cwnd/2=12，cwnd=1重新开始慢启动算法，然后当cwnd=ssthresh=12的时候又开始拥塞避免

   然后假如当cwnd=16的时候，接受到了同一个报文三次重复确认，但是也许并没有发生拥塞所以就启动快重传

3. 快重传-快速恢复：重传数据时就更新ssthresh=当前cwnd/2=8，而cwnd更新为ssthresh 的值==8，然后开始拥塞避免阶段



> `慢启动`算法思想：当主机开始发送数据时，由于并不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞，所以由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值，试探一下网络的拥塞情况。慢开始规定，在发送方每收到一个新的报文段的确认后，拥塞窗口的值就增大1，刚开始我们先设置拥塞窗口值为1，发送方收到一个新的确认报文之后，cwnd变为2，发送方接收到两个新的确认报文之后cwnd加2变成。即拥塞窗口的增长每次都是收到确认报文段数量的2倍。为了防止拥塞窗口增长多大引起网络阻塞，为其设置了一个慢启动门限，当到达门限时，就进入到拥塞避免阶段

> `拥塞避免`算法的思路：不再以指数形式增长拥塞窗口，而是每经过一个往返时间RTT就将发送方的拥塞窗口+1，使其增长缓慢，按照线性方式增长，如果发生网络拥塞，比如丢包时，就将慢启动门限设为原来的一半，然后将拥塞窗口设置为1，开始执行慢启动算法。

> `快速重传`算法思想：快速重传要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。快速重传规定，发送方只要一连接收到3个重复确认，就知道接收方确实没有收到该报文段，因而应当立即进行重传，这样就不会出现超时，发送方也就不会误认为出现了网络拥塞。使用快速重传可以使整个网络的吞吐量提高约20%。快速重传后进入快速恢复。

> `快速恢复`的思想：将慢启动门限值设置为原来的一半，然后将拥塞窗口设置为现在的慢启动的门限值，不再执行慢启动而是直接进入拥塞避免阶段。使发送窗口成线性方式增长。【也有的快速恢复实现是把快速恢复时的拥塞窗口cwnd值再增大一些（即3个报文段长度），即等于新的门限值+3个报文段长度。这样做的理由是，既然发送方收到3个重复的确认，就表明3个分组已经离开了网络。这3个分组不再消耗网络的资源，而是停留在接收方的缓冲区种（接收方发送出了3个重复确认就证明了这个事实）。可见现在网络中并不是堆积了分组，而是减少了3个分组。因此可以适当的把拥塞窗口扩大些】

快速重传的图解：

![img](https://gitee.com/hnistzdk/picture/raw/master/images/202203052037157.png)







## 8.ARP是地址解析协议，简单解释下工作原理

1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。
3. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
4. 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。



## 9.ICMP协议

> ICMP是Internet Control Message Protocol，因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由器是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文。

##  10.DHCP协议

> 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。



## 11.TTL是什么？作用是什么？哪些工具会用到它?

> TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，则将数据包丢弃。
>
> 使用TTL：
>
> - ping发送数据包里面有TTL，但是并非是必须的，即是没有TTL也是能正常工作的
> - traceroute正是因为有了TTL才能正常工作
> - ifconfig是用来配置网卡信息的，不需要TTL
> - netstat是用来显示路由表的，也是不需要TTL的











