---
title: 面向对象
date: 2023-04-25 15:54:09
permalink: /golang/base/oop/
categories:
  - golang
  - 基础
tags:
  - golang
---

# 面向对象相关

## struct

```go
package main

import "fmt"

// UserModel 如果struct名是大写,则表示此结构体在别的包能够被访问 /**
type UserModel struct {
	//如果属性名是大写,则表示该属性在别的包也能够被访问
	Username string
	Password string
	//小写则只能包内访问
	age int
}

// Show 不传入*UserModel,那么变量是数据副本而不是引用
// 默认传入调用当前方法的对象实例 即下面的 user变量
func (user UserModel) Show() {
	fmt.Println("Username = ", user.Username)
	fmt.Println("Password = ", user.Password)
	fmt.Println("age = ", user.age)
}

// 方法也是一样的 方法名的大小写代表了此方法是否能被包外访问
// 这里传入*UserModel表示是引用传递
// 默认传入调用当前方法的对象实例 即下面的 user变量
func (user *UserModel) updateUser() {
	user.age = 1111
}

func main() {

	user := UserModel{Username: "zdk", Password: "123", age: 22}
	user.Show()
	fmt.Println("user:", user)
	fmt.Println("-------------")

	user.updateUser()
	fmt.Println("update-user:", user)

}
```

> 即，struct名、属性名、方法名等，大写表示public包外可访问，小写表示private包外不可访问

## 方法

> 方法总是绑定对象实例,并隐式的将实例作为第一实参(receiver),方法的语法如下

```go
func(receiver ReceiverType) funcName(parameters) (results)
```

- 参数receiver可重新命名.如方法中未曾使用,可省略参数名
- **参数receiver类型可以是T或\*T.基类型T不能是接口或指针**
- 不支持重载方法,也就是说,不能定义名字相同但是不同参数的方法

举例：为上面的UserModel对象定义的方法：

```go
func (user *UserModel) updateUser() {
	user.age = 1111
}
```

> 这里没有传入参数，user变量就是调用者本身







### 重写

> 子类可以重写父类的方法，如上述代码中的
>
> ```go
> func (superMan SuperMan) Walk() {
> 	fmt.Println("superMan--Eat()")
> }
> ```
>
> 在superMan对象进行调用时，就不再是调用`func (human Human) Walk()`方法了，而是调用重写后的方法



## 继承

> 在golang中，如果一个struct嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现继承特性。

例如：

```go
package main

import "fmt"

type Human struct {
	name string
	sex  string
}

type SuperMan struct {
	// SuperMan类继承了Human类的方法和属性
	Human
	level int
}

func (human Human) Eat() {
	fmt.Println("Human--Eat()")
}

func (human Human) Walk() {
	fmt.Println("Human--Eat()")
}

func (superMan SuperMan) Walk() {
	fmt.Println("superMan--Eat()")
}

func main() {

	human := Human{"test", "女"}
	human.Walk()

	fmt.Println("-----------------")

	superMan := SuperMan{Human{"zdk", "男"}, 1}
	superMan.name = "张迪凯"
	superMan.Eat()
	superMan.Walk()
}
```

> 以上代码中，实现了SuperMan类继承了Human类，superMan对象可以直接.属性名来访问Human类的属性。

注意：

1. 结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或者小写的字段、方法，都可以使用
2. 匿名结构体字段访问可以简化，即不需要`superMan.Human.name`，而是直接`superMan.name`
   - 这里是先看superMan有没有name属性，如果有就直接调用
   - 如果没有就回去看SuperMan中嵌入的结构体中的有没有name属性，如果有则调用，没有就继续找别的结构体，如果找完所有内嵌结构体都找不到，就报错
3. 当结构体和匿名结构体有相同的字段或者方法时，编译器选择采用就近访问原则访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分
4. 结构体嵌入两个(或多个)匿名结构体，如两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的子弹和方法)，在访问时，就必须指定匿名结构体名字，否则编译报错
5. 如果一个struct嵌套了一个有名结构体这种模式就是组合，如果是组合关系，那么在访问结构体的字段或方法时，就必须带上结构体的名字

### 多重继承

- 如果一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现多重继承
- 如嵌入的匿名结构体有相同的字段名或者方法名，则在访问时，需要通过匿名结构体类型名来区分
- 为了保证代码的简洁性，尽量不使用多重继承



## interface(多态)

### 定义

定义格式如下：

```go
type 接口名 interface{
方法名1( 参数列表1 ) 返回值列表1
方法名2( 参数列表2 ) 返回值列表2
…
}
```

说明：

1. 接口名：用type将接口自定义的一个类型名。Go语言的接口名单词后面通常会加 er，比如写操作的接口叫 Writer 等。接口名要尽量突出接口类型的含义
2. 方法名：当方法名的首字母以及该接口名首字母都是大写时，那么这个方法可以被接口所在的包（package）之外的代码访问
3. 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可省略



### 实现

存在如下接口：

```go
type Say interface {
	say(str string)
	eat(str string) int
}
```

> 和java一样，要实现go的接口，也必须实现接口中的所有方法，所以实现类应该拥有以下方法

```go
type Cat struct {
	name string
}

func (cat *Cat) say(str string) {
	cat.name = str
	fmt.Println("cat say:", str)
}

func (cat *Cat) eat(str string) int {
	fmt.Println("cat eat:", str)
	return 1
}

type Dog struct {
	name string
}

func (dog *Dog) say(str string) {
	dog.name = str
	fmt.Println("dog say:", str)
}

func (dog *Dog) eat(str string) int {
	fmt.Println("dog eat:", str)
	return 1
}
```

> 方法的返回值和参数列表必须与接口中的方法一致。还有一个类实现多个接口的情况，这里就不举例了

### 使用

> 使用也是和java相似，变量用接口定义，赋值用实现类赋值，即：
>
> 接口类型的变量(指针)，指向(引用)实现类的具体数据变量

```go
func main() {
	var say Say = &Cat{}
	say.say("cat")
	fmt.Println(say)

	fmt.Println("-------------------")

	say = &Dog{}
	say.say("dog")
	fmt.Println(say)
}
```



### 接口嵌套

> 接口的嵌套即接口的继承，定义方法和struct 类的继承是一样的

```go
type Jumper interface {
    jump()
}
 
type Sayer interface {
    say()
}
 
type animal interface {
    Jumper
    Sayer
}
 
type dog struct{
    name string
}
 
func (d *dog) jump() {
    fmt.Printf("%s会跳\n", d.name)
}
 
func (d *dog) say() {
    fmt.Printf("%s会叫\n", d.name)
}
 
func main() {
    var x animal
    x = &dog{name: "小强"}
 
    x.jump()
    x.say()
}
```



### 空接口

通用万能类型接口：`空接口`

```go
interface{} // 
```

> 在go语言中，int、string、float32、float64、struct等都实现了`interface{}`接口，这样就可以使用interface{}类型去引用任意的数据类型，包括go的基本类型和我们自己定义的struct

举例说明一下空接口：

```go
package main

import "fmt"

func show(arg interface{}) {

	fmt.Println("arg : ", arg)

	value, ok := arg.(string)
	if ok {
		fmt.Println("arg is string,value = ", value)
	}
    
	value1, ok1 := arg.(Article)
	if ok1 {
		fmt.Println("arg is Article(struct),value = ", value1)
	}

	value2, ok2 := arg.(int)
	if ok2 {
		fmt.Println("arg is int,value = ", value2)
	}

}

type Article struct {
	title   string
	content string
}

func main() {
	article := Article{"标题", "内容"}
	show(article)
	fmt.Println("--------------")
	show("woshi")
	fmt.Println("--------------")
	show(10086)
}
/** 输出
arg :  {标题 内容}
arg is Article(struct),value =  {标题 内容}
--------------              
arg :  woshi                
arg is string,value =  woshi
--------------              
arg :  10086                
arg is int,value =  10086 
*/
```

> 一个函数或方法以空接口为参数时，可以传递任意实现了空接口的变量，诸如前面说明了的类型，同时，我们可以使用
>
> `value, ok := arg.(参数实际的类型)`
>
> 这是go提供的类型断言机制，如果类型与我们判断的一致，ok变量为true，value为这个变量的实际值；如果不是这个类型，ok为false

