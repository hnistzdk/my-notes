---
title: 二叉树
date: 2022-02-20 19:45:10
permalink: /work/algorithm/binaryTree
categories:
  - 面试刷题
  - 刷题
tags:
  - 二叉树
  - 算法
---

## 递归

> 写递归算法的关键是要明确函数的`定义`是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节

### 二叉树遍历框架

```java
void traverse(TreeNode root){
    if(root == null){
        return;
    }
    //前序遍历相关代码位置
    traverse(root.left);
    //中序遍历相关代码位置
    traverse(root.right);
    //后序遍历相关代码位置
}
```

### 其他数据结构的遍历

```java
/* 迭代遍历数组 */
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {

    }
}

/* 递归遍历数组 */
void traverse(int[] arr, int i) {
    if (i == arr.length) {
        return;
    }
    // 前序位置
    traverse(arr, i + 1);
    // 后序位置
}

/* 迭代遍历单链表 */
void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {

    }
}

/* 递归遍历单链表 */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    // 前序位置
    traverse(head.next);
    // 后序位置
}
```

> 单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，不过没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式

> `根结点是最顶上那个结点,金字塔的塔顶,叶子结点是最下面的结点,即没有子结点的结点`
>
> **前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：
>
> `前序位置的代码在刚刚进入一个二叉树节点的时候执行；`
>
> `后序位置的代码在将要离开一个二叉树节点的时候执行；`
>
> `中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。`



1. 二叉树的前序遍历

   ```java
   class Solution {
       List<Integer> res = new ArrayList<>();
       public List<Integer> preorderTraversal(TreeNode root) {
           traverse(root);
           return res;
       }
       public void traverse(TreeNode root){
           if (root == null){
               return;
           }
           res.add(root.val);
           traverse(root.left);
           traverse(root.right);
       }
   }
   ```

   > res.add(root.val);即在刚进入二叉树结点时执行

2. 二叉树的深度

   ```java
   class Solution {
       int res = 0;
       int curDepth = 0;
       public int maxDepth(TreeNode root) {
           traverse(root);
           return res;
       }
       public void traverse(TreeNode root){
           if (root == null){
               res = Math.max(res, curDepth);
               return;
           }
           curDepth++;
           traverse(root.left);
           traverse(root.right);
           curDepth--;
       }
   }
   ```

   > 利用curDepth维护当前所在位置的深度，每到达一个结点curDepth++，离开该结点时，curDepth--，到达叶子结点后，更新一下最大深度

3. 翻转二叉树

   >  核心思路是将每个结点的左右子结点交换即可，可以在前序位置或后续位置进行交换，最后返回root即可

   ```java
   class Solution {
       public TreeNode invertTree(TreeNode root) {
           if (root == null){
               return null;
           }
           TreeNode temp = root.left;
           root.left = root.right;
           root.right = temp;
           invertTree(root.left);
           invertTree(root.right);
           return root;
       }
   }
   ```

4. 二叉树的层序遍历

   - 迭代方式

     > 利用队列按从左到右的顺序储存每一层的所有结点，每次for循环将这些结点组合成List< Integer>,添加到res列表中，`注意的是，for循环的次数，是当前这次while循环中队列的size()`，而不是直接队列的size()；
     >
     > 每次while循环用于控制层数

     ```java
     class Solution {
         public List<List<Integer>> levelOrder(TreeNode root) {
             List<List<Integer>> res = new ArrayList<>();
             if (root == null){
                 return res;
             }
             Deque<TreeNode> nodeDeque = new LinkedList<>();
             nodeDeque.push(root);
             while (!nodeDeque.isEmpty()){
                 //对当前队列中的每个结点进行处理
                 List<Integer> temp = new ArrayList<>();
                 //当前层的结点数量
                 int curLen = nodeDeque.size();
                 for (int i = 0; i < curLen; i++) {
                     TreeNode curNode = nodeDeque.pop();
                     temp.add(curNode.val);
                     //把当前结点的左右子结点都入队列
                     if (curNode.left != null){
                         nodeDeque.add(curNode.left);
                     }
                     if (curNode.right != null){
                         nodeDeque.add(curNode.right);
                     }
                 }
                 res.add(temp);
             }
             return res;
         }
     }
     ```

5. N叉树的层序遍历

   - 迭代方式

     > 同二叉树的层序遍历类似，只是结点的结构换成了
     >
     > ```java
     > class Node {
     >     public int val;
     >     public List<Node> children;
     > 
     >     public Node() {}
     > 
     >     public Node(int _val) {
     >         val = _val;
     >     }
     > 
     >     public Node(int _val, List<Node> _children) {
     >         val = _val;
     >         children = _children;
     >     }
     > }
     > ```
     >
     > 只需改变入队列时的对象为当前结点的每个子结点即可

     代码：

     ```java
     class Solution {
         public List<List<Integer>> levelOrder(Node root) {
             List<List<Integer>> res = new ArrayList<>();
             if (root == null){
                 return res;
             }
             Deque<Node> nodeDeque = new LinkedList<>();
             nodeDeque.push(root);
             while (!nodeDeque.isEmpty()){
                 //对当前队列中的每个结点进行处理
                 List<Integer> temp = new ArrayList<>();
                 int curLen = nodeDeque.size();
                 for (int i = 0; i < curLen; i++) {
                     Node curNode = nodeDeque.pop();
                     temp.add(curNode.val);
                     List<Node> children = curNode.children;
                     for (int j = 0; j < children.size(); j++) {
                         //把当前结点的所有子结点都入队列
                         nodeDeque.add(children.get(j));
                     }
                 }
                 res.add(temp);
             }
             return res;
         }
     }
     ```

6. 给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

   ```
   struct Node {
     int val;
     Node *left;
     Node *right;
     Node *next;
   }
   ```

   填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

   初始状态下，所有 next 指针都被设置为 `NULL`。

   

   **示例 1：**

   ![img](https://gitee.com/hnistzdk/picture/raw/master/images/202202222101883.png)

   ```
   输入：root = [1,2,3,4,5,6,7]
   输出：[1,#,2,3,#,4,5,6,7,#]
   解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
   ```

   

   **示例 2:**

   ```
   输入：root = []
   输出：[]
   ```

   

   **提示：**

   - 树中节点的数量在 `[0, 212 - 1]` 范围内
   - `-1000 <= node.val <= 1000`

   

   **进阶：**

   - 你只能使用常量级额外空间。

   - 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

     

   `解题思路：`

   - 利用层序遍历

     > 利用二叉树层序遍历的思想，将每层的每两个左右结点之间由左连到右

     ```java
     /*
     // Definition for a Node.
     class Node {
         public int val;
         public Node left;
         public Node right;
         public Node next;
     
         public Node() {}
     
         public Node(int _val) {
             val = _val;
         }
     
         public Node(int _val, Node _left, Node _right, Node _next) {
             val = _val;
             left = _left;
             right = _right;
             next = _next;
         }
     };
     */
     
     class Solution {
         public Node connect(Node root) {
             if (root == null){
                 return root;
             }
             Node res = root;
             LinkedList<Node> nodeDeque = new LinkedList<>();
             nodeDeque.push(root);
             while (!nodeDeque.isEmpty()){
                 //对当前队列中的每个结点进行处理
                 Node left = nodeDeque.get(0);
                 for (int i = 1; i < nodeDeque.size(); i++){
                     //每个左边的结点都和它右边的连上 不管是在同一结点上还是跨结点
                     left.next = nodeDeque.get(i);
                     //连上以后 将右边的结点作为左结点 继续连
                     left = nodeDeque.get(i);
                 }
                 int curLen = nodeDeque.size();
                 for (int i = 0; i < curLen; i++) {
                     Node curNode = nodeDeque.pop();
                     //把当前结点的左右子结点都入队列
                     if (curNode.left != null){
                         nodeDeque.add(curNode.left);
                     }
                     if (curNode.right != null){
                         nodeDeque.add(curNode.right);
                     }
                 }
             }
             return res;
         }
     }
     ```

   - 使用递归：
