---
title: 动态规划
date: 2022-03-04 16:55:01
permalink: /work/algorithm/dp
categories:
  - 面试刷题
  - 刷题
tags:
  - 动态规划
---

# 动态规划

## 概念or套路

**首先，动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求**最长**递增子序列呀，**最小**编辑距离呀等等。

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

首先，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**，才能正确地穷举。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，**写出状态转移方程是最困难的**，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

按上面的套路走，最后的结果就可以套这个框架：

```java
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```



### 1.(`medium`)零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。



示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0


提示：

1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104



思路：

> 官方题解：
>
> 我们采用自下而上的方式进行思考。仍定义F(i)为组成金额i所需最少的硬币数量，假设在计算F(i) 之前，我们已经计算出 F(0)-F(i-1)的答案。 则F(i)对应的转移方程应为
>
> ![image-20220312102627085](https://images.zaiolos.top/images/202203121026130.png)
>
> 其中 cj代表的是第j枚硬币的面值，即我们枚举最后一枚硬币面额是cj，那么需要从 i-cj这个金额的状态 F(i-cj)转移过来，再算上枚举的这枚硬币数量1的贡献，由于要硬币数量最少，所以F(i)为前面能转移过来的状态的最小值加上枚举的硬币数量1。

`理解：dp[i] = min(dp[i],dp[i-coin]+1)。这里相当于最后一枚硬币面额是coin，那么amount==i的情况下，所需数量dp[i]就等于去掉这最后一枚硬币coin的情况时需要的数量，加上硬币coin的1与它本身取最小值`



代码：

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;
        for(int i = 1;i <= amount;i++){
           for(int coin : coins){
               if(i-coin<0){
                   continue;
               }
               dp[i] = Math.min(dp[i-coin]+1,dp[i]);
           } 
        }
        return dp[amount] == (amount+1) ? -1 : dp[amount];
    }
}
```





### 2.(`medium`)股票的最大利润

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。



思路：

> 我们设dp数组，dp[i]为每一天的最大利润。
>
> 
>
> 思考：一天的最大利润是如何得到的呢？
>
> 即：<mark>第i天所能得到的最大利润，如果比原来的最大利润大，那么总的最大利润就是第i天能得到的最大利润；如果比原来的最大利润小，那么总的最大利润仍为[0,i-1]天里的最大利润。</mark>
>
> 
>
> `第i天最大利润的计算：只要知道第[0,i-1]天之间的最小股票价格，用第i天价格减去，就能得到第i天能得到的最大利润`



代码：传统利用数组，这样可以得到每一天的最大利润

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0){
            return 0;
        }
        //设dp[i]为第i天的最大利润
        //每一天的最大利润 等于max(前一天的利润,今天的股票价格-之前最小的股票价格)
        //因为通过今天股票价格和之前的最小价格，我们可以计算到今天所能获得的利润有没有前面的天获得的大
        int res = 0;
        int min = prices[0];
        for(int i=1;i<prices.length;i++){
            if(prices[i]<min){
                min = prices[i];
            }
            res = Math.max(res,prices[i]-min);
        }
        return res;
    }
}
```

`不过由于题目只需要求这些天里的所有利润中的最大利润，所以可以用变量代替数组`

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        int min = Integer.MAX_VALUE;
        for(int i=0;i<prices.length;i++){
            //维护[0,i-1]区间里的最小股票
            min = Math.min(min,prices[i]);
            //比较最大利润与第i的最大利润取其大者
            res = Math.max(res,prices[i]-min);
        }
        return res;
    }
}
```



### 3.(`easy`)连续子数组的最大和

