---
title: 二叉树
date: 2022-02-20 19:45:10
permalink: /work/algorithm/binaryTree
categories:
  - 面试刷题
  - 刷题
tags:
  - 二叉树
  - 算法
---



### 二叉树遍历框架

```java
void traverse(TreeNode root){
    if(root == null){
        return;
    }
    //前序遍历相关代码位置
    traverse(root.left);
    //中序遍历相关代码位置
    traverse(root.right);
    //后序遍历相关代码位置
}
```

### 其他数据结构的遍历

```java
/* 迭代遍历数组 */
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {

    }
}

/* 递归遍历数组 */
void traverse(int[] arr, int i) {
    if (i == arr.length) {
        return;
    }
    // 前序位置
    traverse(arr, i + 1);
    // 后序位置
}

/* 迭代遍历单链表 */
void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {

    }
}

/* 递归遍历单链表 */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    // 前序位置
    traverse(head.next);
    // 后序位置
}
```

> 单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，不过没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式

> `根结点是最顶上那个结点,金字塔的塔顶,叶子结点是最下面的结点,即没有子结点的结点`
>
> **前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：
>
> `前序位置的代码在刚刚进入一个二叉树节点的时候执行；`
>
> `后序位置的代码在将要离开一个二叉树节点的时候执行；`
>
> `中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。`



1. 二叉树的前序遍历

   ```java
   class Solution {
       List<Integer> res = new ArrayList<>();
       public List<Integer> preorderTraversal(TreeNode root) {
           traverse(root);
           return res;
       }
       public void traverse(TreeNode root){
           if (root == null){
               return;
           }
           res.add(root.val);
           traverse(root.left);
           traverse(root.right);
       }
   }
   ```

   > res.add(root.val);即在刚进入二叉树结点时执行

2. 二叉树的深度

   ```java
   class Solution {
       int res = 0;
       int curDepth = 0;
       public int maxDepth(TreeNode root) {
           traverse(root);
           return res;
       }
       public void traverse(TreeNode root){
           if (root == null){
               res = Math.max(res, curDepth);
               return;
           }
           curDepth++;
           traverse(root.left);
           traverse(root.right);
           curDepth--;
       }
   }
   ```

   > 利用curDepth维护当前所在位置的深度，每到达一个结点curDepth++，离开该结点时，curDepth--，到达叶子结点后，更新一下最大深度
