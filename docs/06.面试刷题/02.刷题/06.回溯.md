---
title: 回溯
date: 2022-03-18 10:58:32
permalink: /work/algorithm/backtrack
categories:
  - 面试刷题
  - 刷题
tags:
  - 回溯
---

## 概要及框架

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。



框架

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。



> 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：
>
> **写 `backtrack` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。
>
> 其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？
>
> 某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。



### 1.(`medium`)全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]



思路：

> 回溯：
>
> 我们使用一个boolean数组isOk来保存当前的所有选择的状态，为true证明已被选则，不可被选。
>
> 使用LinkedList来记录每次结果，当它的size到达nums的length的时候，证明产生一个排列，将其加入到res中
>
> `注：res.add(new LinkedList<>(path));`老问题了
>
> 1. 在回溯方法中，如果当前的path长度等于nums长度，证明产生一个排列
> 2. 然后对所有的可选选择进行选择，将其加入到path中,将选择标志isOk[i]记为true
> 3. 然后执行递归
> 4. 递归完成后，将path中的最后一个移出，然后将选择标志isOk[i]记为false
>
> 2、4步即体现了`在递归调用之前「做选择」，在递归调用之后「撤销选择」`





代码：

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] isOk = new boolean[nums.length];
        LinkedList<Integer> path = new LinkedList<>();
        backtrack(path,nums,isOk);
        return res;
    }

    public void backtrack(LinkedList<Integer> path,int[] nums,boolean[] isOk){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(isOk[i]){
                continue;
            }
            path.add(nums[i]);
            isOk[i] = true;
            backtrack(path,nums,isOk);
            path.removeLast();
            isOk[i] = false;
        }
    }
}
```

