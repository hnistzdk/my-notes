---
title: 回溯
date: 2022-03-18 10:58:32
permalink: /work/algorithm/backtrack
categories:
  - 面试刷题
  - 刷题
tags:
  - 回溯
---

## 概要及框架

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。



框架

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。



> 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：
>
> **写 `backtrack` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。
>
> 其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？
>
> 某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。



### 1.(`medium`)全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]



思路：

> 回溯：
>
> 我们使用一个boolean数组flag来保存当前的所有选择的状态，为true证明已被选则，不可被选。
>
> 使用LinkedList来记录每次结果，当它的size到达nums的length的时候，证明产生一个排列，将其加入到res中
>
> `注：res.add(new LinkedList<>(path));`老问题了
>
> 1. 在回溯方法中，如果当前的path长度等于nums长度，证明产生一个排列
> 2. 然后对所有的可选选择进行选择，将其加入到path中,将选择标志flag[i]记为true
> 3. 然后执行递归
> 4. 递归完成后，将path中的最后一个移出，然后将选择标志flag[i]记为false
>
> 2、4步即体现了`在递归调用之前「做选择」，在递归调用之后「撤销选择」`





代码：

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] flag = new boolean[nums.length];
        backtrack(new LinkedList<>(),nums,flag);
        return res;
    }

    public void backtrack(LinkedList<Integer> path,int[] nums,boolean[] flag){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        //遍历所有选择
        for(int i=0;i<nums.length;i++){
            //已选择的 不再选择
            if(flag[i]){
                continue;
            }
            //选择
            path.add(nums[i]);
            //标记置为已选择
            flag[i] = true;
            //递归
            backtrack(path,nums,flag);
            //撤销选择
            path.removeLast();
            //标记置为未选择
            flag[i] = false;
        }
    }
}
```



### 2.(`medium`)全排列2

题目与上题类似，只是数组现在包含重复数字，且要求返回的是所有不重复的全排列



思路：

> 大题思路与上题一致，需要解决的问题：
>
> 如何筛选重复的排列，即减枝
>
> 
>
> 要解决重复问题，我们只要设定一个规则，保证在填第i个数的时候重复数字只会被填入一次即可。而在本题解中，我们选择`对原数组排序`，`保证相同的数字都相邻`，然后`每次填入的数一定是这个数所在重复数集合中「从左往右第一个未被填过的数字」`，即如下的判断条件：
>
> ```java
> if (i > 0 && nums[i] == nums[i - 1] && !flag[i - 1]) {
>     continue;
> }
> ```
>
> 这个判断条件保证了对于重复数的集合，一定是从左往右逐个填入的。
>
> 假设我们有 33 个重复数排完序后相邻，那么我们一定保证每次都是拿从左往右第一个未被填过的数字，即整个数组的状态其实是保证了 [未填入，未填入，未填入] 到 [填入，未填入，未填入]，再到 [填入，填入，未填入]，最后到 [填入，填入，填入] 的过程的，因此可以达到去重的目标。



代码：

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        boolean[] flag = new boolean[nums.length];
        backtrack(new LinkedList<>(),nums,flag);
        return res;
    }

    public void backtrack(LinkedList<Integer> path,int[] nums,boolean[] flag){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        //遍历所有选择
        for(int i=0;i<nums.length;i++){
            //已选择的 不再选择
            if(flag[i]){
                continue;
            }
            //如果前面的相邻相等元素没有用过，则跳过
            if(i>0&&nums[i]==nums[i-1]&&!flag[i-1]){
                continue;
            }
            //选择
            path.add(nums[i]);
            //标记置为已选择
            flag[i] = true;
            //递归
            backtrack(path,nums,flag);
            //撤销选择
            path.removeLast();
            //标记置为未选择
            flag[i] = false;
        }
    }
}
```



### 3.(`medium`)划分为k个相等的子集

给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

示例 1：

输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
示例 2:

输入: nums = [1,2,3,4], k = 3
输出: false


提示：

1 <= k <= len(nums) <= 16
0 < nums[i] < 10000
每个元素的频率在 [1,4] 范围内



思路：

> 将每个子集看作是一个桶，有多少个子集就有多少个桶，然后遍历nums，向桶中添加元素
>
> - 如果循环完nums都无法装满当前的桶，证明无法分成k个总和相等的非空子集，返回false
> - 循环时做减枝
>   - 如果当前的数字已被使用，跳过
>   - 如果sum+nums[i]>target即当前桶装不下，跳过
> - 然后将nums[i]装入桶，继续递归第i+1个数字是否能装入当前桶
> - 如果当前桶装满了，递归装下一个 backtrack(k-1,0,target,0,nums,flag);
> - 直到所有桶都被装满 返回true
>
> 递归函数：
>
> ```java
> public boolean backtrack(int k,int sum,int target,int start,int[] nums,boolean[] flag)
> ```
>
> k表示桶个数，sum表示当前桶的值，target表示桶装满的值，start表示从数组的哪个位置开始选择数字装入桶，flag记录数字是否已被使用



代码：

```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum = Arrays.stream(nums).sum();
        if(sum%k!=0){
            return false;
        }
        //每个子集的和
        int target = sum/k;
        boolean[] flag = new boolean[nums.length];
        return backtrack(k,0,target,0,nums,flag);
    }

    public boolean backtrack(int k,int sum,int target,int start,int[] nums,boolean[] flag){
        //所有桶被装满了 返回true
        if(k == 0){
            return true;
        }
        //这个桶装满了 装下一个
        if(sum == target){
            return backtrack(k-1,0,target,0,nums,flag);
        }
        for(int i=start;i<nums.length;i++){
            //数字已被使用 跳过
            if(flag[i]){
                continue;
            }
            //当前桶装不下 跳过
            if(sum+nums[i]>target){
                continue;
            }
            //选择 将nums[i]装入当前桶
            sum+=nums[i];
            flag[i] = true;
            //递归穷举下一个数字(第i+1个数字)是否能装入当前桶
            if(backtrack(k,sum,target,i+1,nums,flag)){
                return true; 
            }
            //撤销
            sum-=nums[i];
            flag[i] = false;
        }
        //穷举所有数字都无法装满当前桶
        return false;
    }
}
```

