---
title: 秒杀项目过程笔记
date: 2022-05-15 20:24:04
permalink: /project/seckill
categories:
  - 项目
  - 秒杀项目
tags:
  - 
---



## Java秒杀方案



### 1、页面优化

#### 1.1、缓存

> 使用redis存储渲染后的html的String，存入redis，过期时间60ms。
>
> 访问时先判断redis中是否存在页面的缓存，如果存在，使用`ThymeleafViewResolver`进行解析，然后返回解析后的字符串。
>
> 注意：这样返回需要加上`@ResponseBody`注解，否则会报错

```java
	@ApiOperation(value = "商品页面")
    @GetMapping(value = "/toList",produces = "text/html;charset=utf-8")
    @ResponseBody
    public String toList(Model model, User user){
        //因为使用的了HandlerMethodArgumentResolver
        //就能省略 方法参数获取cookie,再通过cookie找User,再转换的过程
        //而直接将User作为入参进行判断即可
        if (user == null){
            return "login";
        }
        String html = redisUtil.get("goodsList");
        //获取页面 如果不为空 直接返回
        if (isOk(html)){
            return html;
        }
        //获取页面 如果为空 手动渲染 存入redis 再返回
        model.addAttribute("user", user);
        model.addAttribute("goodsList", goodsService.findGoodsVo());
        //最后一个map的参数 作为要返回的属性  就是model的attribute
        WebContext context = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());
        //进行解析
        html = thymeleafViewResolver.getTemplateEngine().process("goodsList", context);
        if (isOk(html)){
            //存入redis
            redisUtil.set("goodsList", html,60);
        }
        return html;
    }
```

商品详情页面同理：

```java
	@ApiOperation(value = "商品详情页")
    @GetMapping(value = "/toDetail",produces = "text/html;charset=utf-8")
    @ResponseBody
    public String toDetail(Model model,User user,Long goodsId){
        if (user == null){
            return "login";
        }
        //如果存在 直接返回
        String html = redisUtil.get("goodsDetails:"+goodsId);
        if (isOk(html)){
            return html;
        }
        //为空 渲染 缓存 返回
        GoodsVo goodsVo = goodsService.findGoodsVoById(goodsId);
        Date startDate = goodsVo.getStartDate();
        Date endDate = goodsVo.getEndDate();
        Date now = new Date();
        int secKillStatus;
        //秒杀倒计时秒数
        long remainSeconds;
        //秒杀持续时间
        long seckillSeconds = 0;
        //秒杀未开始
        if (now.before(startDate)){
            secKillStatus = 0;
            remainSeconds = (startDate.getTime()-now.getTime())/1000;
        } else if (now.after(endDate)){
            //秒杀已结束
            secKillStatus = 2;
            remainSeconds = -1;
        } else{
            //秒杀进行中
            seckillSeconds = (endDate.getTime()-now.getTime())/1000;
            secKillStatus = 1;
            remainSeconds = 0;
        }
        model.addAttribute("seckillSeconds", seckillSeconds);
        model.addAttribute("secKillStatus", secKillStatus);
        model.addAttribute("remainSeconds", remainSeconds);
        model.addAttribute("user", user);
        model.addAttribute("goods", goodsVo);

        WebContext context = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());
        html = thymeleafViewResolver.getTemplateEngine().process("goodsDetail", context);
        if (isOk(html)){
            redisUtil.set("goodsDetails:"+goodsId, html,60);
        }
        return html;
    }
```



::: tip 压测

<Badge text="在此配置下：8核8线程i7-9700的windows"/>

1000个线程 重复10次，测三次 相当于30000

- 优化前QPS：1835.9/sec
- 页面缓存优化后QPS：4448.4/sec

有2.4倍的提升

:::



#### 1.2、静态化分离

> 即把页面的静态部分写死，然后通过Ajax获取动态数据，然后通过jQuery显示



### 2、服务优化

#### 2.1、RabbitMQ消息队列

#### 2.2、接口优化

1. 库存存到redis中，进行预减库存



#### 2.3、分布式锁



### 3、安全优化

#### 3.1、隐藏秒杀地址

#### 3.2、验证码

#### 3.3、接口限流



### 4、分布式会话

#### 4.1、用户登录

##### 登录逻辑

> 系统是使用mobile作为id的，密码是经过了`MD5(MD5(pass明文+固定salt)+salt)`两次md5加密的；
>
> 第一次是前端通过固定salt先对密码加密一次
>
> ```js
> //salt
> var g_passsword_salt="1a2b3c4d"
> 
> let inputPass = $("#password").val();
> let salt = g_passsword_salt;
> let str = salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4);
> let password = md5(str);
> ```
>
> 第二次是后端再通过这个用户注册时生成的salt再对密码加密一次(注册没有写 逻辑是这样的)
>
> 
>
> 所以登录的时候，先通过手机号判断是否有这个用户，有的话再看他的密码与使用他的salt加密后的 输入密码  是否相等，不等则抛出对应GlobalException。
>
> 
>
> 验证成功以后，为这个用户生成一个形式为UUID的凭证ticket，并把它存入redis并设置过期时间，然后封装为一个cookie返回给前端

```java
```







##### 参数校验

> 为了避免写太多的StringUtils.xxx这种冗余代码，我们可以引入validation的包来处理。下面引入依赖
>
> ```xml
> <!--        validation组件-->
>         <dependency>
>             <groupId>org.springframework.boot</groupId>
>             <artifactId>spring-boot-starter-validation</artifactId>
>         </dependency>
> ```





**方式1:使用组件自带的校验**

1. 首先，如果要校验的参数是对象，则将`@Valid`加对象前面(如果是String、Integer这些，直接使用对应的`@NotNull`等注解即可)。

   ```java
   	//这里注意，必须要在Controller的方法之中使用
   	//测试如果在service的方法中使用，不会生效
   	@PostMapping("/doLogin")
       @ResponseBody
       public ApiResp toLogin(@Valid LoginVo loginVo) {
           log.info("loginVo:{}",loginVo);
           return userService.doLogin(loginVo);
       }
   ```

2. 在类的属性上加上对应的注解即可，还可以在注解中指定校验失败时的message

   ```java
   @Data
   public class LoginVo {
       @NotBlank(message = "手机号不能为空")
       private String mobile;
   
       @NotBlank(message = "密码不能为空")
       @Length(min = 32)
       /**
        * 可以用Pattern正则对手机号进行验证，如果用了，在不满足时，会抛出BindException
        * 此时需要我们手动处理(使用@RestControllerAdvice)，否则前端就得不到具体的响应
        *
        * 当然 也可以自定义注解
        */
       @Pattern(regexp = "[1]([3-9])[0-9]{9}$")
       private String password;
   }
   ```



**方式2:通过自定义注解实现自定义的校验**

1. 参考`@NotNull`注解定义我们的手机号格式校验注解

   ```java
   @Target({METHOD,FIELD,ANNOTATION_TYPE,CONSTRUCTOR,PARAMETER,TYPE_USE})
   @Retention(RUNTIME)
   @Documented
   //这里是指定由哪个类来具体进行校验
   //这个类需实现ConstraintValidator<A extends Annotation,T>接口并实现所有方法
   @Constraint(validatedBy = {IsMobileValidator.class})
   public @interface IsMobile {
       //标识这个属性是必填的
       boolean required() default true;
   	//默认错误信息
       String message() default "手机号码格式错误";
   
       Class<?>[] groups() default {};
   
       Class<? extends Payload>[] payload() default {};
   }
   ```

2. 定义`ConstraintValidator<A extends Annotation,T>接口`实现类，实现它的两个方法

   ```java
   public class IsMobileValidator implements ConstraintValidator<IsMobile,String> {
       private boolean required = false;
   
       //具体的校验逻辑
       @Override
       public boolean isValid(String value, ConstraintValidatorContext context) {
           //如果不是必填的 并且为空 直接返回true
           if (!required && StringUtils.isBlank(value)){
               return true;
           }
           //如果必填 或者非必填时它填了  就需要校验
           return ValidatorUtil.isMobile(value);
       }
   
       //在这个方法实现对required的初始化
       @Override
       public void initialize(IsMobile constraintAnnotation) {
           required = constraintAnnotation.required();
       }
   }
   ```

   校验工具类：

   ```java
   public class ValidatorUtil {
       private static final Pattern MOBILE_PATTEN = Pattern.compile("[1]([3-9])[0-9]{9}$");
   
       /**
        * 手机号码校验
        * @param mobile
        * @return
        */
       public static boolean isMobile(String mobile) {
           if (StringUtils.isEmpty(mobile)) {
               return false;
           }
           Matcher matcher = MOBILE_PATTEN.matcher(mobile);
           return matcher.matches();
       }
   }
   ```

3. 在字段上加上自定义注解即可

   ```java
   @Data
   public class LoginVo {
       @NotBlank(message = "手机号不能为空")
       @IsMobile
       private String mobile;
   
       @NotBlank(message = "密码不能为空")
       @Length(min = 32)
       private String password;
   }
   ```



> 这样我们就完成了参数的校验，但是我们会发现，此时虽然参数校验成功了，后端代码并没有往下执行了，但前端并任何提示，这其实是因为，参数校验不通过时，Validator抛出了`BindException`(大都是抛出它的子类`MethodArgumentNotValidException`)，而我们并没有对这个异常进行处理，所以前端没有获取到对应的响应信息，所以我们需要添加一个全局异常的处理类来进行处理



##### 参数校验的全局异常处理

1. 自定义全局异常类。一定要继承RuntimeException类，而不是Exception类，如果是Exception类的话，抛出异常是需要在方法上throws的

   ```java
   /**
    * @author zdk
    * @date 2022/5/15 18:13
    * 全局异常类
    */
   @Data
   @AllArgsConstructor
   @NoArgsConstructor
   public class GlobalException extends RuntimeException{
       private ApiRespEnum apiRespEnum;
   }
   ```

2. 这里选择使用`@RestControllerAdvice`类型的全局异常处理类

   ```java
   @Slf4j
   @RestControllerAdvice
   public class GlobalExceptionHandler {
       
       @ExceptionHandler(Exception.class)
       public ApiResp handle(Exception e){
           //处理自定义的异常
           if (e instanceof GlobalException){
               GlobalException exception = (GlobalException) e;
               return ApiResp.error(exception.getApiRespEnum());
           }
           //处理使用的Validator组件的异常
           else if(e instanceof BindException) {
               BindException bindException = (BindException) e;
               ApiResp respBean = ApiResp.error(ApiRespEnum.BIND_ERROR);
               respBean.setMessage("参数校验异常：" + bindException.getBindingResult().getAllErrors().get(0).getDefaultMessage());
               return respBean;
           }
           e.printStackTrace();
           log.error("异常信息:{}",e.getMessage());
           return ApiResp.error(ApiRespEnum.ERROR);
       }
   
   }
   ```



::: tip 总结



:::







#### 4.2、共享Session

##### 一些解决方案

- Session复制
  - 优点
    - 无需修改代码，只需要修改Tomcat配置
  - 缺点
    - Session同步传输占用内网带宽
    - 多台Tomcat同步时，性能指数级下降
    - Session占用内存，无法有效水平扩展
- 前端存储
  - 优点
    - 不占用服务端内存
  - 缺点
    - 存在安全风险
    - 数据大小受cookie限制
    - 占用外网带宽
- Session粘滞(一致性Hash)
  - 优点
    - 无需修改代码
    - 服务端可以水平扩展
  - 缺点
    - 增加新机器，会重新Hash，导致重新登录
    - 应用重启，需要重新登录
- 后端集中存储
  - 优点
    - 安全
    - 容易水平扩展
  - 缺点
    - 增加复杂度
    - 需要修改代码

##### Spring Session实现分布式Session

1. 添加依赖

   ```xml
   <!--Spring Boot Redis -->
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-data-redis</artifactId>
           </dependency>
   <!--Spring的分布式session-->
           <dependency>
               <groupId>org.springframework.session</groupId>
               <artifactId>spring-session-data-redis</artifactId>
           </dependency>
   <!--对象池依赖  Redis的lettuce对象池可能会用到-->
           <dependency>
               <groupId>org.apache.commons</groupId>
               <artifactId>commons-pool2</artifactId>
           </dependency>
   ```

2. 配置redis

   ```yaml
   #redis配置
     redis:
       host: 211.69.238.77
       password: 
       port: 6379
       database: 1
       #连接超时时间
       timeout: 10000ms
       lettuce:
         pool:
           #最大连接数 默认8
           max-active: 8
           #最大连接阻塞时间 默认-1
           max-wait: 1000ms
           #最大空闲连接，默认8
           max-idle: 200
   ```

3. 上面的步骤执行以后，`set到Session的值 会被自动加入到redis中`

   ```java
   request.getSession().setAttribute("user:"+ticket, user);
   ```

   ![image-20220516162347445](https://images.zaiolos.top/images/image-20220516162347445.png)



##### Redis存储用户信息

直接根据生成的ticket存储即可

```java
		//生成一个ticket 并设置过期时间
        String ticket = UUID.randomUUID().toString();
        //存入redis
        redisUtil.set("user:"+ticket, user, 60*60);
        CookieUtil.setCookie(request, response, "userTicket", ticket,60*60);
```



#### 4.3、优化登录

> 在优化前，我们在需要User信息的Controller方法中，都需要在方法入参上加入`@CookieValue("userTicket") ticket`，然后在方法代码中通过判断ticket是否存在来跳转，存在时还要通过它去redis获取用户信息，过于重复和繁琐，所以我们使用`HandlerMethodArgumentResolver`优化

1. 首先创建一个类，实现`HandlerMethodArgumentResolver`接口

   ```java
   /**
    * @author zdk
    * @date 2022/5/16 18:19
    * 对Controller中的方法中的  User类型的参数做统一判断
    */
   @Component
   public class UserHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver {
   
       @Autowired
       private UserService userService;
   
       /**
        * 如果参数的类型是User 才交由resolveArgument方法处理
        * @param parameter
        * @return
        */
       @Override
       public boolean supportsParameter(MethodParameter parameter) {
           Class<?> clazz = parameter.getParameterType();
           return clazz == User.class;
       }
   
       @Override
       public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) {
           HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
           String userTicket = CookieUtil.getCookieValue(request, "userTicket");
           if (StringUtils.isBlank(userTicket)){
               return null;
           }
           return userService.getUserByCookie(userTicket);
       }
   }
   ```

   > 这里面就通过cookie去获取了User对象，所以我们在Controller的方法参数上只需要写一个`User user`，然后在代码中对它判断一次即可

2. 还要进行MVC的配置，添加MVC配置类

   ```java
   /**
    * @author zdk
    * @date 2022/5/16 18:09
    */
   @Configuration
   public class WebMvcConfig implements WebMvcConfigurer {
   
       @Autowired
       private UserHandlerMethodArgumentResolver userHandlerMethodArgumentResolver;
   	
       @Override
       public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
           //User类型的入参判断
           resolvers.add(userHandlerMethodArgumentResolver);
       }
   }
   ```

3. 在方法中直接填入User参数即可

   ```java
    @GetMapping("/toList")
       public String toList(Model model,User user){
           //因为使用的了HandlerMethodArgumentResolver
           //就能省略 方法参数获取cookie,再通过cookie找User,再转换的过程
           //而直接将User作为入参进行判断即可
           if (user == null){
               return "login";
           }
           model.addAttribute("user", user);
           return "goodsList";
       }
   ```

   





### 5、功能开发

#### 5.1、商品列表

> 简单的显示秒杀商品的列表，显示图片、原价、秒杀价、秒杀库存数量

#### 5.2、商品详情

> 主要是显示秒杀商品的开始时间、开始前的倒计时(秒)、正在秒杀状态、时间结束后的秒杀结束状态

::: tip 思路

后端提供两个信息：秒杀状态和秒杀开始倒计时

1. 秒杀商品表含有秒杀开始时间和结束时间，在后端查出秒杀商品信息后，用当前时间与秒杀开始时间和结束时间作对比
2. 如果当前时间在`秒杀开始时间之前`，则为秒杀未开始状态，需要计算倒计时并渲染到前端
3. 如果在`秒杀结束时间`之后，则为秒杀已结束状态，将按钮变更为不可点击
4. 如果在两者之间，证明秒杀正在进行，这里前端其实还需要对 `秒杀结束时间-当前时间`进行倒计时，倒计时结束后显示秒杀已结束，然后变更按钮状态，但教程中并未实现，只能通过刷新一次才能变成秒杀已结束状态。试着实现了一下，前端太拉了，没成功

:::

#### 5.3、秒杀

::: tip 简略版

用户一下单，查数据库判断库存，不足则返回错误；再判断是否重复秒杀(看秒杀订单里是否该用户已秒杀了该商品)，如果重复，返回错误；然后正常下单，下单时，扣库存、新增普通订单和秒杀订单数据

:::



::: tip 简单优化

进入秒杀service中后，通过`一开始不查商品,直接扣库存,扣库存使用stock_count = stock_count - 1并且判断当前stock_count>0`来扣库存、订单插入增加user_id和goods_id的唯一索引防止超卖(仅在单体中不超卖，分布式系统这种方式不能解决超卖问题)，同时在判断是否重复秒杀时，将秒杀订单存在redis，避免查数据库，提高速度

:::

#### 5.4、订单详情



### 6、系统压测

#### 6.1、JMeter入门

修改jmeter.properties：添加`language=zh_CN、sampleresult.default.encoding=UTF-8`这两个属性

::: tip 一些概念

- **QPS**：(`Queries Per Second`) 是每秒查询率，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器**在规定时间内**所处理的流量多少的衡量标准，即每秒的响应请求数，也即是最大[吞吐量](https://so.csdn.net/so/search?q=吞吐量&spm=1001.2101.3001.7020)。

- **TPS** (`Transactions Per Second`) 也就是事务数/秒。一个事物是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数

- **QPS和TPS区别**：TPS即每秒处理事务数，包括了`用户请求服务器`、`服务器自己的内部处理`、`服务器返回给用户`这三个过程，每秒能够完成N个这一组过程，TPS就是N；QPS基本类似于TPS，但是不同的是，`对于一个页面的一次访问，形成一个TPS`；`但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入"QPS"之中`

- **并发数**(并发度)：指系统同时能处理的请求数量，同时反应了系统的负载能力。这个数值可以分析机器1S内的访问日志数量来得到

- **吞吐量**：吞吐量是指系统在单位时间内处理请求的数量，TPS、QPS都是吞吐量的常用量化指标。

  - **系统吞吐量要素**：一个系统的吞吐量（承压能力）与request(请求)对cpu的消耗，外部接口，IO等等紧密关联。

    单个request对cpu消耗越高，外部系统接口，IO影响速度越慢，系统吞吐能力越低，反之越高

  - **重要参数**：QPS、TPS、并发数、响应时间

- **关系**：QPS(TPS)=并发数/平均响应时间

:::

#### 6.2、自定义变量

#### 6.3、正式压测
