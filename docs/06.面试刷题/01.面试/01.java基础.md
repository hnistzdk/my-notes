---
title: java基础
date: 2022-02-20 19:57:49
permalink: /work/interview/java
categories:
  - 面试刷题
  - 面试
tags:
  - 
---

## 集合框架

### List

#### ArrayList扩容

> 新容量为原数组长度的1.5倍，如果扩容后的容量依然小于需要的容量，就将需要容量作为数组的长度。
>
> 然后将原数组元素拷贝到新的数组并返回

```java
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

#### ArrayList在jdk7、8的不同

1. jdk7

   - ArrayList list = new ArrayList()；//底层elementData数组初始大小为10
   - 执行add()时，如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中

2. jdk8

   > 底层elementData初始化为{}，并没有初始化为长度10的数组，而是第一次调用add的时候，底层才创建了长度为10的数组，并将数据加入到数组。后续的添加和扩容操作与JDK7无异

3. 总结：

   > JDK7中的ArrayList的对象创建类似于单例模式中的饿汉式，而JDK8中的类似于懒汉式，延迟了数组的创建，节省了内存





### Set

#### HashSet

> 底层也是数组(是一个HashMap)，初始容量为16，当如果使用率超过0.75，(16*0.75=12)就会扩大容量为原来的2倍。(16扩容为32，依次为64,128.....等) 详情见HashMap源码

添加元素的过程

> 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为:索引位置），判断数组此位置上是否已经有元素: 
>
> ​	如果此位置上没有其他元素，则元素α添加成功。---->情况1 
>
> ​	如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值: 如果hash值不相同，则元素α添加成功。---->情况2 
>
> ​	如果hash值相同，进而需要调用元素α所在类的equals()方法: 如果equals()返回true,元素α添加失败 如果equals()返回false,则元素α添加成功。---->情况3
>
> 
>
> 对于添加成功的情况2和情况3而言:元素a与已经存在指定索引位置上数据以链表的方式存储。
>
> 
>
> jdk7：元素α放到数组中，指向原来的元素。 jdk8：原来的元素在数组中，指向元素α



### Map

#### HashMap

##### 1.HashMap的底层原理

> 在jdk1.7之前HashMap是基于数组和[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)实现的，而且采用头插法。
>
> 
>
> 而jdk1.8 之后在解决哈希冲突时有了较大的变化，当[链表]()长度大于阈值（默认为 8）（将[链表]()转换成[红黑树]()前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为[红黑树]()）时，将[链表]()转化为[红黑树]()，以减少搜索时间。采用尾插法。

##### 2.HashMap怎么扩容

HashMap默认的初始化大小为 16。当HashMap中的**元素个数之和**大于负载因子*当前容量的时候就要进行扩充，容量变为原来的 2 倍。（这里注意不是数组中的个数，而且数组中和链/树中的所有元素个数之和！）

> 注意：我们还可以在预知存储数据量的情况下，提前设置初始容量（初始容量 = 预知数据量 / 加载因子）。这样做的好处是可以减少 resize() 操作，提高 HashMap 的效率

##### 3.HashMap是线程不安全的吗

HashMap是线程不安全的，其主要体现在：

1. 在jdk1.7中，多线程环境下，扩容时可能会造成环形链或数据丢失
2. 在jdk1.8中，多线程环境下，会发生数据覆盖的情况

##### 4.HashMap扩容的时候为什么是2的n次幂？

数组下标的计算方法是(n - 1) & hash，**取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。**



##### 5.HashMap的put方法

1. 根据key通过哈希算法和与运算得出数组下标
2. 如果该数组下标元素为空，则将key和value封装为Entry对象(jdk1.7是Entry对象，1.8是Node对象)，并放入该位置
3. 如果数组下标位置元素不为空，则要分情况
   - 如果在jdk1.7中，会`首先判断是否需要扩容`，如果要扩容就先进行扩容，如果不需要则生成Entry对象，并用头插法添加到当前链表中。
   - 如果是在jdk1.8中，则会先判断当前位置上的TreeNode类型，看是红黑树还是链表Node
     - 如果是红黑树TreeNode，则会将key和value封装为一个红黑树结点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value
     - 如果此位置上的Node对象时链表结点，则将key和value封装为一个Node并通过`尾插法`插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，遍历的过程中会判断是否存在当前key，如果存在则更新其value，否则遍历完链表后，将新的Node插入到链表，插入后会看当前链表的结点个数，如果大于8，将会将这条链表转为红黑树
     - 将key和value封装为Node插入到链表或红黑树以后，再判断是否需要扩容，如果需要扩容，就结束put方法

#### ConcurrentHashMap

> 在jdk1.7是 **分段的数组+[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)** ，jdk1.8的时候跟HashMap1.8的时候一样都是基于数组+[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)/[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)。

ConcurrentHashMap是线程安全的

1. 在jdk1.7的时候是使用分段所segment，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
2. 在jdk1.8的时候摒弃了 Segment的概念，而是直接用 Node 数组+[链表]()+[红黑树]()的数据结构来实现，并发控制使用 **`synchronized`** 和 **CAS** 来操作。synchronized只锁定当前[链表]()或红黑[二叉树]()的首节点



