---
title: 数组
date: 2022-03-01 09:19:30
permalink: /work/algorithm/array
categories:
  - 面试刷题
  - 刷题
tags:
  - 数组
---



## 普通的数组相关题

### 1.(`easy`)移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

思路1：

> 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。
>
> 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
>
> 注意到以下性质：
>
> 左指针左边均为非零数；
>
> 右指针左边直到左指针处均为零。
>
> 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。
>



代码：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0;
        int right = 0;
        while (right < nums.length) {
            if (nums[right] != 0) {
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }

    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```





思路2：

> 使用双指针，左指针始终指向0的位置，右指针指向非0位置。
>
> - 如果当前左右指针都不为0，将两个指针都向后移一位
> - 如果左指针为0，右指针不为0，交换，将两个指针都向后移一位
> - 其他情况就只移动右指针即可



代码：

```java
public void moveZeroes(int[] nums) {
        int left = 0;
        int right = 0;
        while (right < nums.length) {
            if (nums[left] != 0 && nums[right] != 0) {
                left++;
            }
            else if(nums[left] == 0 && nums[right] != 0){
                swap(nums,left,right);
                left++;
            }
            right++;
        }
    }
```



### 2.(`medium`)和为K的子数组

给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

 

示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

输入：nums = [1,2,3], k = 3
输出：2



思路1：

> 很容易想到利用前缀和，得出每个[0,i]区间的子数组之和，然后[i,j]区间之和就等于[0,j]-[0,i]。
>
> 求出前缀和以后，枚举所有区间前缀和之差，等于k就res加一。
>
> 时间复杂度为O(n2)，空间复杂度O(1)
>
> 
>
> 我的比官方暴力要快几百ms

代码：

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        int[] preSum = new int[nums.length];
        preSum[0] = nums[0];
        for(int i = 1;i<nums.length;i++){
            preSum[i] = preSum[i-1]+nums[i];
        }
        for(int i = 0;i<preSum.length;i++){
            if(preSum[i] == k){
                res++;
            }
            for(int j = i+1;j<preSum.length;j++){
                if(preSum[j]-preSum[i] == k){
                    res++;
                }
            }
        }
        return res;
    }
}
```



思路2：

> 因为暴力的时间复杂度很高，我们可以利用hash表对算法进行优化。
>
> 暴力时我们使用的是 [0,j]-[0,i]==k 即是否存在两个前缀和之差等于k来寻找符合条件的[i,j]子数组。
>
> 
>
> 我们可以换个思路，使用一个HashMap<Integer,Integer>()，将前缀和以key存入HashMap，value为这种前缀和出现的次数，
>
> 比如k=7，数组为：0 7 2 5 3 -1，前缀和为：0 7 9 14 17 16，
>
> 我们要找前缀和之间差为7的，只需要去map里面找每个前缀和，有多少个与它之差为7的。
>
> 所以我们把每个前缀和以及它的数量存入map，找到key为 当前前缀和-k，的前缀和的数量让res加上即可在O(1)内获得结果
>
> 
>
> 这种思想的根本是，不是用区间(前缀和)去找差为K的区间数量，而是根据一个前缀和A，去找另一个满足A-B==K的前缀和B的数量

代码：

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        int pre = 0;
        HashMap<Integer,Integer> map = new HashMap<>();
        //先put一个0进去是为了nums[i]==k的情况，即只有一个元素的子数组
        map.put(0,1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            if(map.containsKey(pre-k)){
                res+=map.get(pre-k);
            }
            map.put(pre, map.getOrDefault(pre,0)+1);
        }
        return res;
    }
}
```



### 3.(`medium`)在排序数组中查找元素的第一个和最后一个位置

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {
            return new int[]{leftIdx, rightIdx};
        } 
        return new int[]{-1, -1};
    }

    public int binarySearch(int[] nums, int target, boolean lower) {
        int left = 0, right = nums.length - 1, ans = nums.length;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```



### 4.(`medium`)航班预订统计

这里有 n 个航班，它们分别从 1 到 n 进行编号。

有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。

请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。

 

示例 1：

输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
示例 2：

输入：bookings = [[1,2,10],[2,2,15]], n = 2
输出：[10,25]
解释：
航班编号        1   2
预订记录 1 ：   10  10
预订记录 2 ：       15
总座位数：      10  25
因此，answer = [10,25]



思路：

> 从题目例子不难看出，题目实际上就是给你一个长度为n，每个元素初始为0的int数组，让你对它进行多次[i,j,incr]操作，即对第i到第j个的值都加上incr(闭区间)，很容易想到差分数组。
>
> 差分数组即differ[i] = nums[i]-nums[i-1],i>=1 (`differ[0]=nums[0]本身`)
>
> 所以对差分数组求前缀和，可以得到原数组
>
> 举例:
>
> 原数组：     1 2 3 4 5 6 9  原差分数组：1 1 1 1 1 3
>
> 
>
> 对第3-5个加2：1 2 5 6 7 6 9  增加后：   1 3 1 1 -1 3
>
> 从例子可以看出，对原数组的[i,j]区间的数进行同时增加，相当于对差分数组differ：differ[i]+=incr,differ[j+1]-=incr

代码：

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int count = bookings.length;
        int[] differ = new int[n];
        for(int i=0;i<count;i++){
            differ[bookings[i][0]-1] += bookings[i][2];
            if(bookings[i][1]<n){
                differ[bookings[i][1]] -= bookings[i][2];
            }
        }
        for(int i=1;i<n;i++){
            differ[i] += differ[i-1];
        }
        return differ;
    }
}
```

复杂度分析

- 时间复杂度：O(n+m)，其中 n 为要求的数组长度，m 为预定记录的数量。我们需要对于每一条预定记录处理一次差分数组，并最后对差分数组求前缀和。
- 空间复杂度：O(1)。我们只需要常数的空间保存若干变量，注意返回值不计入空间复杂度。



### 5.(`easy`)爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶
2. 2 阶
示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶



思路1：

> 因为只有两种爬楼梯方式，一次爬1个台阶或2个台阶，所以我们如果要爬到n个台阶，肯定是从第n-1个台阶或第n-2个台阶爬上去的，这样就可以得到爬到n的方式数量为 爬到n-1的方式数量+爬到n-2的方式数量，即f(n)=f(n-1)+f(n-2)，是经典的斐波那契数列

代码：

```java
class Solution {
    //使用一个res中间变量
    public int climbStairs(int n) {
        int a = 1;
        int b = 2;
        int res = n;
        for(int i=2;i<n;i++){
            res = a+b;
            a = b;
            b = res;
        }
        return res;
    }
    //不使用中间变量
    public int climbStairs(int n) {
        if(n == 1 ||n == 2){
            return n;
        }
        int a = 1,b = 2;
        for(int i=2;i<n;i++){
            b = a+b;
            a = b-a;
        }
        return b;
    }
}
```



### 6.(`medium`)旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

![image-20220305143656376](https://gitee.com/hnistzdk/picture/raw/master/images/202203051436449.png)



思路：

> 先将原数组按左上到右下的对角线交换元素，再将数组每一行反转即可得到数组顺时针旋转90度的图像
>
> 同理，先将原数组按右上到左下的对角线交换元素，再将数组每一行反转即可得到数组逆时针旋转90度的图像



代码：

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        //将数组按对角线反转
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        //再反转每一行
        for(int k=0;k<n;k++){
            int i = 0,j = n-1;
            while(i<j){
                int temp = matrix[k][j];
                matrix[k][j] = matrix[k][i];
                matrix[k][i] = temp;
                i++;
                j--;
            } 
        }
    }
}
```



### 7.(`medium`)螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

**示例 1：**

![img](https://gitee.com/hnistzdk/picture/raw/master/images/202203051725128.jpeg)

```sh
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

思路：

`解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界`：

![image-20220305172700670](https://gitee.com/hnistzdk/picture/raw/master/images/202203051727764.png)

随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组：

![image-20220305172718694](https://gitee.com/hnistzdk/picture/raw/master/images/202203051727746.png)



代码：

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int up = 0,down = m-1,left = 0,right = n-1;
        List<Integer> res = new ArrayList<>();
        while(res.size()<m*n){
            if(up<=down){
                //在顶部最左从左往右遍历
                for(int k = left;k<=right;k++){
                    res.add(matrix[up][k]);
                }
                up++;
            }
            if(left<=right){
                //在顶部最右从上往下遍历
                for(int k = up;k<=down;k++){
                    res.add(matrix[k][right]);
                }
                right--;
            }
            if(up<=down){
                //在底部最右从右往左遍历
                for(int k = right;k>=left;k--){
                    res.add(matrix[down][k]);
                }
                down--;
            }
            if(left<=right){
                //在底部最左从下往上遍历
                for(int k = down;k>=up;k--){
                    res.add(matrix[k][left]);
                }
                left++;
            }
        }
        return res;
    }
}
```



### 8.(`medium`)螺旋矩阵||

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

![image-20220305173139642](https://gitee.com/hnistzdk/picture/raw/master/images/202203051731686.png)

思路与上题基本一致，只需要add到List的操作换成赋值为当前num即可



代码：

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int up = 0,down = n-1,left = 0,right = n-1;
        int[][] res = new int[n][n];
        int num = 1;
        while(num<=n*n){
            if(up<=down){
                //在顶部最左从左往右遍历
                for(int k = left;k<=right;k++){
                    res[up][k] = num++;
                }
                up++;
            }
            if(left<=right){
                //在顶部最右从上往下遍历
                for(int k = up;k<=down;k++){
                    res[k][right] = num++;
                }
                right--;
            }
            if(up<=down){
                //在底部最右从右往左遍历
                for(int k = right;k>=left;k--){
                    res[down][k] = num++;
                }
                down--;
            }
            if(left<=right){
                //在底部最左从下往上遍历
                for(int k = down;k>=up;k--){
                    res[k][left] = num++;
                }
                left++;
            }
        }
        return res;
    }
}
```





## 二分查找、双指针相关

### 1.(`easy`)二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1


提示：

你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。



思路：

> 有序数组，使用二分查找，以nums[mid]与target的大小关系决定应该往右边找还是往左边找

代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = left+(right-left)/2;
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                right = mid-1;
            }else if(nums[mid]<target){
                left = mid+1;
            }
        }
        return -1;
    }
}
```



### 2.(`easy`)在排序数组中查找数字 1

统计一个数字在排序数组中出现的次数。

 

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: 0


提示：

0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums 是一个非递减数组
-109 <= target <= 109



思路：

> 常规是直接一趟循环记录target数量即可，时间复杂度为O(n)，没有利用到数组是非递减 这个条件；
>
> 
>
> 使用二分：
>
> 我们的目的是找到第一个大于target的元素位置和第一个小于target的元素位置
>
> 1. 找第一个大于target的元素位置
>
>    我们寻找当前数组范围内的mid值，如果nums[mid]大于目标值，右指针对mid左移一位，如果`小于等于目标值`，则左指针对mid右移一位。`注意小于等于这个判断条件这里，小于的时候，右移是毋庸置疑的；等于的时候也要继续右移，就是要找下一个可能比mid大的`，当左右指针到达同一位置时，mid也为这个位置，如果num[mid]大于目标值，那么右指针right左移一位，现在left>right了，循环结束，`此时的left所在位置，即为边界位置`，即第一个大于target的元素位置![image-20220307165558912](https://gitee.com/hnistzdk/picture/raw/master/images/202203071655967.png)
>
> 2. 找第一个小于target的元素位置
>
>    与1相似，只是在判断如果nums[mid]`大于等于`目标值的时候，都要左移，以便找到第一个小于target的元素位置



`复杂度分析：`

- **时间复杂度O(logN)：** 二分法为对数级别复杂度。
- **空间复杂度O(1)：** 几个变量使用常数大小的额外空间。



代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        int leftBound = 0;
        int rightBound = 0;
        int left = 0;
        int right = nums.length-1;
        //找右边界：即第一个大于target的元素位置
        while(left<=right){
            int mid = left+(right-left)/2;
            if(nums[mid]>target){
                right = mid-1;
            }else if(nums[mid]<=target){
                left = mid+1;
            }
        }
        //已找到右边界 以右边界作为重新搜索的右边界
        rightBound = left;
        left = 0;
        //找左边界 即第一个小于target的元素位置
        while(left<=right){
            int mid = left+(right-left)/2;
            if(nums[mid]>=target){
                right = mid-1;
            }else if(nums[mid]<target){
                left = mid+1;
            }
        }
        leftBound = right;
        return rightBound-leftBound-1;
    }
}
```



### 3.(`easy`)排序数组中两个数字之和

给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0 开始计数 ，所以答案数组应当满足 0 <= answer[0] < answer[1] < numbers.length 。

假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。



思路：

> 因为数组是升序排列，所以可以使用左右指针，每次计算左右指针数之和，如果大于target，说明右边的数太大了，右指针减一，如果小于target，说明左边的数小了，左指针加一，直到和等于target就break，或左右指针相遇退出循环(因为题目保证会存在且只存在一对符合条件的数字，同时一个数字不能使用两次)



代码：

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length-1;
        int sum = 0;
        while(left<right){
            sum = numbers[left]+numbers[right];
            if(sum>target){
                right--;
            }else if(sum<target){
                left++;
            }else{
                break;
            }
        }
        return new int[]{left,right};
    }
}
```



### 4.(`medium`)两数之和2

题目与上题类似，只是数组规定下标从1开始，返回的结果下标都加1即可，纯双指针解法不再赘述



更好的解法：二分+双指针

> - 先二分判断如果left+mid大于target，那么可以直接更新right到mid-1；
> - 二分判断如果right+left小于target，那么可以直接更新left到mid+1；
> - 后面的操作和纯双指针一样
>
> 在最好的情况下，每次都走二分，时间复杂度为O(logN)，最坏的情况为纯双指针，复杂度O(N)



代码：

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length-1;
        int sum = 0;
        while(left<right){
            int mid = left+(right-left)/2;
            sum = numbers[left]+numbers[right];
            if(numbers[left]+numbers[mid]>target){
                right = mid-1;
            }else if(numbers[mid]+numbers[right]<target){
                left = mid+1;
            }else if(sum>target){
                right--;
            }else if(sum<target){
                left++;
            }else{
               return new int[]{left+1,right+1};
            }
        }
        return new int[]{left+1,right+1};
    }
}
```





