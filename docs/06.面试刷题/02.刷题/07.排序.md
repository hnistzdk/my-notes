---
title: 排序
date: 2022-03-18 10:58:32
permalink: /work/algorithm/sort
categories:
  - 面试刷题
  - 刷题
tags:
  - 排序
---



## 归并排序

### 代码框架

```java
// 定义：排序 nums[lo..hi]
void sort(int[] nums, int lo, int hi) {
    if (lo == hi) {
        return;
    }
    int mid = (lo + hi) / 2;
    // 利用定义，排序 nums[lo..mid]
    sort(nums, lo, mid);
    // 利用定义，排序 nums[mid+1..hi]
    sort(nums, mid + 1, hi);

    /****** 后序位置 ******/
    // 此时两部分子数组已经被排好序
    // 合并两个有序数组，使 nums[lo..hi] 有序
    merge(nums, lo, mid, hi);
    /*********************/
}

// 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]
// 合并为有序数组 nums[lo..hi]
void merge(int[] nums, int lo, int mid, int hi);
```





## 题目

### 1.(`medium`)排序数组

给你一个整数数组 nums，请你将该数组升序排列。

示例 1：

输入：nums = [5,2,3,1]
输出：[1,2,3,5]
示例 2：

输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]

**提示：**

- `1 <= nums.length <= 5 * 104`
- `-5 * 104 <= nums[i] <= 5 * 104`



#### 使用归并排序

> 归并排序是将数组每次递归拆分为两个部分，对这两个部分进行排序后，再将这两个已排序的数组合并(方法类似合并两个有序链表)，按此步骤递归即可



代码：

```java
class Solution {
    int[] temp;
    public int[] sortArray(int[] nums) {
        temp = new int[nums.length];
        sort(nums,0,nums.length-1);
        return nums;
    }

    public void sort(int[] nums,int low,int high){
        if(low == high){
            return;
        }
        int mid = low+(high-low)/2;
        sort(nums,low,mid);
        sort(nums,mid+1,high);
        merge(nums,low,mid,high);
    }

    public void merge(int[] nums,int low,int mid,int high){
        for(int i=low;i<=high;i++){
            temp[i] = nums[i];
        }
        //与双指针合并两个有序链表类似
        int i = low,j = mid+1;
        for(int k=low;k<=high;k++){
            if(i == mid+1){
                //此时左边部分数组已全部被合并，所以当前的num[k]的值应该等于当前的j所在位置的值
                //即该等于右边部分数组的指针位置的值
                nums[k] = temp[j++];
            }else if(j == high+1){
                //类似上面 此时右边部分数组已全部被合并
                nums[k] = temp[i++];
            }else if(temp[i]<temp[j]){
                nums[k] = temp[i++];
            }else{
                nums[k] = temp[j++];
            }
        }
    }
}
```



另一种写法：不适用merge函数，直接将逻辑写到后序代码位置对数组进行处理

```java
class Solution {
    int[] temp;
    public int[] sortArray(int[] nums) {
        temp = new int[nums.length];
        sort(nums,0,nums.length-1);
        return nums;
    }

    public void sort(int[] nums,int low,int high){
        if(low == high){
            return;
        }
        int mid = low+(high-low)/2;
        sort(nums,low,mid);
        sort(nums,mid+1,high);
        for(int i=low;i<=high;i++){
            temp[i] = nums[i];
        }
        int i = low,j = mid+1;
        for(int k=low;k<=high;k++){
            if(i == mid+1){
                nums[k] = temp[j++];
            }else if(j == high+1){
                nums[k] = temp[i++];
            }else if(temp[i]<temp[j]){
                nums[k] = temp[i++];
            }else{
                nums[k] = temp[j++];
            }
        }
    }
}
```





#### 时间复杂度分析

> 递归算法的复杂度计算，就是子问题个数 x 解决一个子问题的复杂度。对于归并排序来说，时间复杂度显然集中在 `merge` 函数遍历 `nums[lo..hi]` 的过程，但每次 `merge` 输入的 `lo` 和 `hi` 都不同，所以不容易直观地看出时间复杂度。
>
> `merge` 函数到底执行了多少次？每次执行的时间复杂度是多少？总的时间复杂度是多少？
>
> ![image-20220326173853464](https://images.zaiolos.top/images/202203261738631.png)
>
> 
>
> **执行的次数是二叉树结点的个数，每次执行的复杂度就是每个结点代表的子数组的长度，所以总的时间复杂度就是整棵树中数组元素的个数**。所以从整体是哪个看，这个二叉树的高度是logN，其中每一层的元素个数就是原数组的长度N，所以总的时间复杂度就是`O(NlogN)`。
