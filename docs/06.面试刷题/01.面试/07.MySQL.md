---
title: MySQL
date: 2022-03-27 19:17:14
permalink: /work/interview/MySQL
categories:
  - 面试刷题
  - 面试
tags:
  - MySQL
---

## 思维导图



<iframe src="https://gitmind.cn/app/doc/3df7437297" width="100%" height="500" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>











## 索引结构相关

### 树的种类

<Badeg text="按有序性" type="warning"/>

> 无序树：树中任意结点的子节点之间没有顺序关系
>
> 有序树：树中任意结点的子节点之间有顺序关系



<Badeg text="按结点包含子树个数" type="warning"/>

> - 二叉树：每个节点最多含有两个子树的树称为二叉树;
>
> - 满二叉树：除最后一层的节点外，其他所有结点都有两个子节点的二叉树
>
> - 完全二叉树：除去最后一层，为满二叉树；最后一个层的结点，优先从左到右(连续集中在左边)
>
> - 霍夫曼树：带权路径最短的二叉树。
>
> - 红黑树：红黑树是一颗特殊的二叉查找树，每个节点都是黑色或者红色，根节点、叶子节点是黑色。如果一个节点是红色的，则它的子节点必须是黑色的。
>
> - 二叉查找树：首先它是一颗二叉树，若左子树不空，则左子树上所有结点的值均小于它的根结点的值;若右子树不空，则右子树上所有结点的值均大于它的根结点的值;左、右子树也分别为二叉排序树;
>
>   <Badeg text="最好情况下查找效率为O(logN)，但是当二叉树只向一边堆积形成一条链表时，效率就是O(N)了。所以有了AVL树"/>
>
> - 平衡二叉树(AVL)：可以是空树；不是空树的时候，它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树



### MySQL索引要解决的问题

<Badge text="减小耗时更多的磁盘IO次数，用高速的内存查找去替换" type="error"/>



### AVL树(平衡二叉树的一种)

> 我们对二叉查找树做个限制，限制必须满足任何节点的两个子树的最大差为 1，也是AVL 树的定义，这样我们的查找效率就有了一定的保障。
>
> AVL 树 是一种自平衡二叉查找树(self-balancing binary search tree)。
>
> 当然，维护AVL 树也是需要一定开销的，即当树插入/更新/删除新的数据时假设破坏了树的平衡性，那么需要通过左旋和右旋来维护树的平衡。
>
> 当数据量很多时，同样也会出现二叉树过高的情况。
>
> 我们知道AVL 树的查找效率为 O(logN)，也就是说，当树过高时，查找效率会下降。
>

::: tip AVL树不适合作索引

另外由于我们的索引文件并不小，所以是存储在磁盘上的。

文件系统需要从磁盘读取数据时，一般以页为单位进行读取，假设一个页内的数据过少，
那么操作系统就需要读取更多的页，涉及磁盘随机 I/O 访问的次数就更多。

将数据从磁盘读入内存涉及随机 I/O 的访问，是数据库里面成本最高的操作之一。

因而这种树高会随数据量增多急剧增加，每次更新数据又需要通过左旋和右旋维护平衡的二叉树，不太适合用于存储在磁盘上的索引文件



注意，我们说的平衡二叉树结构，指的是逻辑结构上的平衡二叉树，其物理实现是数组。然后由于在逻辑结构上相近的节点在物理结构上可能会差很远。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。

而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构。

:::



### B-Tree(Balance Tree)

### 介绍

> B树属于多叉树，又名平衡多路查找树。它能够保证数据有序，还保证了在查找、插入、删除等操作时性能都能保持在O(logN)，为大块数据的读写操作做了优化。一般描述一颗B树时需要指定它的阶数，`阶数表示一个结点最多可以有多少个孩子结点`，当阶数为2时，即常见的二叉搜索树。
>
> 
>
> <Badge text="同二叉搜索树类似，B树的每个结点储存了多个key和子树(指向下一磁盘块的地址指针)，子树与key按顺序排列"/>
>
> B树在保留二叉树预划分范围从而提升查询效率的思想的前提下，做了以下优化：
>
> 二叉树变成 m 叉树，这个 m 的大小可以根据单个页的大小做对应调整，从而使得一个页可以存储更多的数据，从磁盘中读取一个页可以读到的数据就更多，随机 IO 次数变少，大大提升效率。
>
> `但是我们看到，我们只能通过中序遍历查询全表，当进行范围查询时，可能会需要中序回溯`
>
> ![image-20220418183728189](https://images.zaiolos.top/images/image-20220418183728189.png)

#### 特点(m阶的B-Tree)

> 1. 根节点最少可以只有一个关键字
> 2. 除根节点外，每个节点最多有m-1个关键字，最少有Math.ceil(m/2)-1个关键字 `TIP：Math.ceil()表示向上取整，例如ceil(2.5)=3`
> 3. 每个节点中的关键字都按照从小到大的顺序排列，每个关键字左指针指向的子树中的所有关键字都小于它，而右指针指向的子树中的所有关键字都大于它
> 4. 所有叶子节点的都位于同一层，或者说根节点到每个叶子节点的长度都相同

#### 3阶B-Tree示意图

![image-20220418164651206](https://images.zaiolos.top/images/image-20220418164651206.png)

> 1.  x.n = 2 有俩个关键字
>     分别为 x.key1 = 8  x.key2 = 12 且 8<12
> 2.  含有3个指向它孩子的指针P1 P2 P3
> 3.  关键字x.key1=8 它的左边指针P1 对 子树 3 5 分割 满足 3和5都小于8
>     关键字x.key1=8 它的右边指针P2 对 子树 9 10 分割 满足 9和10都大于8（同为12的左指针）
>     关键字x.key2=12 它的右边指针P3 对 子树 13 15 分割 满足 13和15都大于12

> 在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小。每个结点中存储了关键字（key）和关键字对应的数据（data），以及孩子结点的指针。我们将一个key和其对应的data称为一个记录。此时B树中的key就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。





### B+Tree

#### 特点

> ![image-20220418183904077](https://images.zaiolos.top/images/image-20220418183904077.png)
>
> <Badge text="B+树在B树的基础上加了以下优化："/>
>
> 1.`叶子结点增加了指针进行连接，即叶子结点间形成了链表；`
>
> 2.`非叶子结点只存关键字 key，不再存储数据，只在叶子结点存储数据；`
>
> 说明：叶子之间用双向链表连接比单向链表连接多出的好处是通过链表中任一结点都可以通过往前或者往后遍历找到链表中指定的其他结点。
>
> 
>
> <Badge text="这样做的好处是："/>
>
> 范围查询时可以通过访问叶子节点的链表进行有序遍历，而不再需要中序回溯访问结点。
>
> 非叶子结点只存储关键字key，一方面这种结构相当于划分出了更多的范围，加快了查询速度，另一方面相当于单个索引值大小变小，同一个页可以存储更多的关键字，读取单个页就可以得到更多的关键字，可检索的范围变大了，相对 IO 读写次数就降低了。

#### 查找过程



![image-20220418154152271](https://images.zaiolos.top/images/image-20220418154152271.png)



::: note 通过主键id查询的过程

按主键id=15查询，首先判断到15在1-18之间，所以来到第二层的(1,16,12)数据块继续查找，二分判断到15>12，所以来到这个结点的最右子节点数据块(12,15,17)查找，它是个链式结构，最后找到id为15的数据，经过三次I/O操作。

:::



::: note 通过非主键(辅助索引)查询

会先检索辅助索引构成的B+Tree的商品编号，找到对应的叶子结点，获取主键值，然后再通过主键索引中的B+Tree查询到对应的叶子结点，获取整行数据。<Badge text="这个过程叫回表" type="error"/>

:::



### B树和B+树的区别

::: warning 区别

1. B 树非叶子结点和叶子结点都存储数据,因此查询数据时，时间复杂度最好为 O(1),最坏为 O(log n)。

   而B+ 树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)。

2. B+ 树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B树只能通过中序遍历。

:::



### B+树比B树更适合应用于数据库索引

::: warning Why?

1. B+ 树更加适应磁盘的特性，相比 B 树减少了 I/O 读写的次数。由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机 I/O 读取次数相对就减少了。
2. B+ 树的查询效率相比B树更加稳定，由于数据只存在在叶子结点上，所以查找效率固定为 O(log n)。
3. B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，利于扫库和范围查询；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。

:::





## 事务相关

### ACID原则

::: note

- 原子性：事务满足原子性，所有操作要么都执行成功，要么都不执行
- 一致性：事物开始和完成时，数据都必须保持一致状。比如：如果从A账户转账到B账户，不可能A账户扣了钱，而B账户没有加钱
- 隔离性：并发环境中，各事务之间的执行不被其它事务干扰，即不同的并发事务操作相同的数据时，每个事务都有自己的完整数据空间
- 持久性：事务对数据库的操作是写入磁盘，哪怕宕机重新运行也是事务结束后的状态

:::



### 隔离级别

MySQL的InnoDB引擎的默认隔离级别是 <Badge text="可重复读" type="warning"/>

::: note 

- 读未提交：其它事务可以看到别的事务未提交但已修改的数据
- 读已提交：其它事务只能看到别的事务已提交的数据
- 可重复读：一个事务在执行过程中看到的数据，总是和这个事务启动时看到的数据一致，未提交变更对其他事务也是不可见的。
- 串行化：让所有事务排队执行，解决了所有问题，但是也不能并发了

:::



### 隔离级别导致的问题

::: note

1. 脏读：主要是`读未提交`这个级别导致的，可以读到别的事务的未提交的数据
2. 幻读：一个事务执行两次查询，发现两次结果不同(倾向于别的事务新增了数据)
3. 不可重复读：一个事务执行两次查询，发现两次结果不同(倾向于同一条数据被修改)

:::



