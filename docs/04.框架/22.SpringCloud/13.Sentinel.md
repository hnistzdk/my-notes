---
title: Sentinel
date: 2022-11-18 18:09:35
permalink: /SpringCloud/Sentinel/
categories:
  - 框架
  - SpringCloud
  - SpringCloud Alibaba
tags:
  - Sentinel
  - SpringCloud Alibaba
---
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Sentinel](#sentinel)
  - [概述](#%E6%A6%82%E8%BF%B0)
    - [hystrix的不足](#hystrix%E7%9A%84%E4%B8%8D%E8%B6%B3)
    - [Sentinel](#sentinel-1)
  - [安装Sentinel控制台](#%E5%AE%89%E8%A3%85sentinel%E6%8E%A7%E5%88%B6%E5%8F%B0)
    - [安装步骤](#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4)
  - [初始化演示工程](#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%BC%94%E7%A4%BA%E5%B7%A5%E7%A8%8B)
    - [cloudalibaba-sentinel-service8401](#cloudalibaba-sentinel-service8401)
      - [pom](#pom)
      - [yaml](#yaml)
      - [主启动类](#%E4%B8%BB%E5%90%AF%E5%8A%A8%E7%B1%BB)
      - [业务类FlowLimitController](#%E4%B8%9A%E5%8A%A1%E7%B1%BBflowlimitcontroller)
  - [流控规则](#%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99)
    - [基本介绍](#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D)
      - [进一步解释说明](#%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E)
    - [流控模式](#%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F)
      - [直接(默认)](#%E7%9B%B4%E6%8E%A5%E9%BB%98%E8%AE%A4)
        - [QPS](#qps)
        - [线程数](#%E7%BA%BF%E7%A8%8B%E6%95%B0)
      - [关联](#%E5%85%B3%E8%81%94)
      - [链路](#%E9%93%BE%E8%B7%AF)
    - [流控效果](#%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C)
      - [直接->快速失败(默认效果)](#%E7%9B%B4%E6%8E%A5-%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E9%BB%98%E8%AE%A4%E6%95%88%E6%9E%9C)
      - [预热(Warm Up)](#%E9%A2%84%E7%83%ADwarm-up)
        - [应用场景](#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
      - [排队等待](#%E6%8E%92%E9%98%9F%E7%AD%89%E5%BE%85)
  - [降级规则](#%E9%99%8D%E7%BA%A7%E8%A7%84%E5%88%99)
  - [热点key限流](#%E7%83%AD%E7%82%B9key%E9%99%90%E6%B5%81)
  - [系统规则](#%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99)
  - [@SentinelResource](#sentinelresource)
  - [服务熔断功能](#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E5%8A%9F%E8%83%BD)
  - [规则持久化](#%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

---

# Sentinel

## 概述

- GitHub：https://github.com/alibaba/Sentinel
- 官网：https://sentinelguard.io/zh-cn/

### hystrix的不足

> 1. 需要手动搭建监控平台
> 2. 没有一套web界面可以给我们进行更加细粒度化地对流控、速率、服务熔断、服务降级等进行控制

### Sentinel

> 其实就是前面的Hystrix的超集，但更加方便易用

![image-20221119145733331](https://images.zaiolos.top/images/202211191457442.png)

## 安装Sentinel控制台

> 直接在GitHub下载release版本的sentinel-dashboard.jar包即可，这里使用的是1.8.6版本

sentinel组件也是由两部分组成：即后台的监控程序+前台的dashboard

- 核心库(Java客户端)：不依赖任何框架/，库，能够运行于所有Java运行环境，同时对Dubbo/SpringCloud等框架有较好的支持
- 控制台(Dashboard)基于SpringBoot开发，打包后可以直接运行，不需要额外的Tomcat等应用容器

### 安装步骤

- 下载好jar包以后，java -jar命令运行即可
- 通过 http://localhost:8080访问管理界面，账号密码均为`sentinel`

![image-20221119150445084](https://images.zaiolos.top/images/202211191504183.png)

![image-20221119150543494](https://images.zaiolos.top/images/202211191505559.png)

## 初始化演示工程

- 首先启动8848Nacos注册中心

- 然后，新建`cloudalibaba-sentinel-service8401`模块

### cloudalibaba-sentinel-service8401

#### pom

> 这里提前引入了一些后面需要的依赖，仅此处的话只需要nacos-discovery和spring-cloud-starter-alibaba-sentinel

```xml
<dependencies>
        <!--        通用的依赖-->
        <dependency>
            <groupId>com.zdk</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- nacos依赖 -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
        <!-- ribbon依赖 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>
        <!-- sentinel依赖 -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
        </dependency>
        <!-- 后续做持久化需要用到 -->
        <dependency>
            <groupId>com.alibaba.csp</groupId>
            <artifactId>sentinel-datasource-nacos</artifactId>
        </dependency>
        <!-- openfeign -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

    </dependencies>
```

#### yaml

```yaml
server:
  port: 8401


spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        #nacos 注册中心地址
        server-addr: localhost:8848
    sentinel:
      transport:
        # 配置Sentinel dashboard地址
        dashboard: localhost:8080
        # sentinel的端口 默认是8719 如果被占用会自动从8719开始依次+1扫描
        # 直到找到未被占用的端口为止
        port: 8719

# actuator的必要配置
management:
  endpoints:
    web:
      exposure:
        include: '*'

```

#### 主启动类

```java
@EnableDiscoveryClient
@SpringBootApplication
public class MainApp8401{
    public static void main(String[] args){
        SpringApplication.run(MainApp8401.class,args);
    }
}
```



#### 业务类FlowLimitController

```java
@RestController
public class FlowLimitController {

    @GetMapping(value = "/testA")
    public String testA(){
        return "------testA";
    }

    @GetMapping(value = "/testB")
    public String testB(){
        return "------testB";
    }

}
```

- 然后启动Sentinel8080、启动新建微服务8401
- 启动后查看sentinel控制台

> 查看我们会发现并没有任何变化，这是因为sentinel是懒加载，我们只需要访问一次接口：
>
> http://localhost:8401/testA 即可看到变化

![image-20221119153333876](https://images.zaiolos.top/images/202211191533985.png)



> 多访问几次接口就会出现实时监控的图表信息

![image-20221119153556122](https://images.zaiolos.top/images/202211191535233.png)

> 这就证实了sentinel正在监控8401微服务

## 流控规则

### 基本介绍

![image-20221119154045404](https://images.zaiolos.top/images/202211191540510.png)

#### 进一步解释说明

- 资源名：唯一名称，默认为请求的路径
- 针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default(不区分来源)
- 阈值类型/单机阈值：
  - QPS(每秒钟的请求数量)：当调用该api的QPS达到设置的阈值时，进行限流
  - 线程数：当调用该api的线程数达到设定的阈值时，进行限流
- 是否集群：sentinel是否是集群
- 流控模式：
  - 直接：api达到限流条件时，直接限流
  - 关联：当关联的资源达到阈值时，就限流自己
  - 链路：只记录指定链路上的流量(指定资源从入口资源进来的流量，如果达到阈值，就进行限流)[api级别的针对来源]
- 流控效果：
  - 快速失败：直接失败，抛出异常
  - Warm Up：根据coldFactor(冷加载因子，默认3)的值，从阈值/coldFactor，经过预热时长，才达到设置的QPS阈值

### 流控模式

> 一般我们在簇点链路这里添加流控规则，因为资源名有了，不用再写，当然也可以在流控规则菜单添加
>
> ![image-20221119155139349](https://images.zaiolos.top/images/202211191551454.png)

#### 直接(默认)

> 按照上图新增一个模式为直接的流控规则，QPS为1，这时对testA接口进行测试，1秒内多次点击，会出现`Blocked by Sentinel (flow limiting)`的提示，因为我们设置的每秒只能请求1次，若超过次数，就直接-快速失败，报默认错误



![image-20221119155335443](https://images.zaiolos.top/images/202211191553505.png)

##### QPS

> 设置阈值类型为QPS时，是限制api每秒能接受的请求的个数，相当于多余的请求还未进入到应用程序就被限制

##### 线程数

> 设置线程数，是限制这个api，同时只有设置的个数的线程在处理请求，假设我们设定线程数阈值为1，这时如果一个请求还未处理完，另一个请求又进来了，这个新进的请求就会出现`Blocked by Sentinel (flow limiting)`

#### 关联

> 即当关联的资源达到阈值的时候，就限流自己，比如接口A关联了接口B，此时接口B达到阈值了，A就该对自己限流了

![image-20221119161646241](https://images.zaiolos.top/images/202211191616350.png)

> 我们用postman模拟对testB接口的并发密集访问，20个线程每0.3秒访问一次testB接口

![image-20221119162438436](https://images.zaiolos.top/images/202211191624551.png)

> 执行这个集合后再去访问testA，即限流成功，而等20个线程0.3秒共6秒访问testB完毕后，testA调用恢复正常

![image-20221119162626835](https://images.zaiolos.top/images/202211191626899.png)

#### 链路

> 多个请求调用同一个微服务

### 流控效果

#### 直接->快速失败(默认效果)

> 刚才已经测试了，即：直接失败，抛出异常Blocked by Sentinel (flow limiting)

源码：com.alibaba.csp.sentinel.slots.block.flow.controller

#### 预热(Warm Up)

> Warm Up (RuleConstant.CONTROL_BEHAVIOR_WARM_UP)方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。

![image-20221119163746226](https://images.zaiolos.top/images/202211191637363.png)

根据设置的这个图通俗解释一下：

> 在sentinel中，默认的冷加载因子coldFactor是3，所以在刚开始的时候，testB接口的QPS的阈值为 threshold/coldFactor = 10/3 = 3，然后预热时长为5(单位是秒)，表示从接口第一次被访问开始的5秒内，testB的QPS阈值都是3，要直到5秒后，testB接口的QPS阈值才会从3慢慢上升到我们设置的10

##### 应用场景

> 如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值。
>
> 或者对应到缓存，先放一部分让缓存成功出现，再放大部分进来就都能走缓存而不是打到数据库了

#### 排队等待

- 匀速排队，让请求以均匀的速度通过，阈值类型必须设为QPS，否则无效

![image-20221119165132840](https://images.zaiolos.top/images/202211191651917.png)

- 设置含义：testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒

![image-20221119174805027](https://images.zaiolos.top/images/202211191748114.png)

> 这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。



## 降级规则



## 热点key限流



## 系统规则



## @SentinelResource



## 服务熔断功能



## 规则持久化

